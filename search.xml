<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[MySQL的四种隔离级别]]></title>
      <url>%2FMySQL%2FMySQL%2FMySQL%E7%9A%84%E5%9B%9B%E7%A7%8D%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%2F</url>
      <content type="text"><![CDATA[SQL标准定义了4类隔离级别，这是非常重要的知识点，是每个程序猿都应该熟练掌握的。 理论基础Read Uncommitted（读取未提交内容）在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少。读取未提交的数据，也被称之为脏读（Dirty Read）。 Read Committed（读取提交内容）这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。这种隔离级别 也支持所谓的不可重复读（Nonrepeatable Read），因为同一事务的其他实例在该实例处理其间可能会有新的commit，所以同一select可能返回不同结果。 Repeatable Read（可重读）这是MySQL的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。不过理论上，这会导致另一个棘手的问题：幻读 （Phantom Read）。简单的说，幻读指当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行。InnoDB和Falcon存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control）机制解决了该问题。 Serializable（可串行化）这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争。 不同隔离级别产生的各种问题 隔离级别 脏读 不可重复读 幻读 read uncommitted √ √ √ read committed × √ √ repeatable read × × √或× serializable × × × 为什么第三行的幻读是不确定的呢？因为这取决你数据库内选择的是何种存储引擎，比如InnoDB就通过多版本并发控制（MVCC，Multiversion Concurrency Control）机制解决了幻读了问题。 脏读事务T1可以看到事务T2未提交的内容。 举例：病人A的性别是男性，事务T1开启事务想查看病人A的性别，这个时候事务T2，先行一步，手滑把病人A的性别改成了女性，没有提交数据库，此时事务T1读到的病人A的性别是女性。事务T2发现改错了，回滚了事务，但是事务T1已经读到了“脏”数据。 不可重复读由于事务T2对数据的修改，导致事务T1连续查询两次数据，发现两次查询出的数据不一致。 举例：病人A的性别是男性，事务T1开启事务第一次查看病人A的性别是男性，这时事务T2把病人A的性别改为女性，并提交。事务T1第二次查看病人A的性别，发现变成了女性。 幻读事务T1按一定条件读取数据，这个时候事务T2如果在该条件内删除或新增数据，会导致事务T1再次读取数据的时候，会发现数据变多/少了。 举例： 如果事务T1在第一次读取的时候对数据进行了更新，那么事务T2新增的幻读的数据就被漏改了。就像幻觉一样。 如果事务T1在第一次读取的时候发现数据有5条，这时事务T2新增或删除了一条数据，事务T1再次查询的时候，发现记录不是5条了。就像幻觉一样。 动手操作环节上面的概念不需要死记硬背，跟着下面的步骤试验一遍就能心里有数了。 以MySQL数据库为例。 准备库表与基础数据在test库下新增表test，表结构如下12345CREATE TABLE `test` ( `id` int(11) NOT NULL AUTO_INCREMENT, `num` int(11) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; 插入三条基础数据123INSERT INTO test (num) VALUES(1);INSERT INTO test (num) VALUES(2);INSERT INTO test (num) VALUES(3); 进入MySQL命令行，不知道如何进入的点击这里 通过use test;进入具体的库 通过show tables;查看所有表 下面开两个窗口，A窗口代表事务T1，B窗口代表事务T2，通过修改A窗口的事务隔离级别来试验。 1. 将A的隔离级别设置为read uncommitted(读未提交)A：设置隔离级别 set session transaction isolation level read uncommitted; A：查看隔离级别 select @@tx_isolation; B：查看隔离级别 A的隔离级别设置只对当前连接有效，查看B的隔离级别，可以发现，还是MySQL默认的隔离级别REPEATABLE-READ。 这里B窗口就使用默认的隔离级别就可以了，不需要修改。 A：进入事务，并查询 start transaction; B：进入事务，并更新一条记录 注意，此时B窗口还没有提交事务。 A：再次查询 可以看到，A读到了B没有提交的事务。 B：回滚事务 通过rollback;来回滚事务。 A：再次查询 如果B新增/删除记录，不提交的话。A也是能看到的。这里就不演示了。 2. 将客户端A的事务隔离级别设置为read committed(读已提交)A：设置隔离级别 set session transaction isolation level read committed; A：开启事务，并查询 B：开启事务，并修改 A：查询 我们发现A没有读取到B没有提交的事务。 B：提交事务 commit; A：查询 可以看到脏读问题解决了，但是出现了不可重复读的问题。也就是A窗口第一次查询和第二次查询的结果不一样。 3. 将A的隔离级别设置为repeatable read(可重复读)A：设置隔离级别 set session transaction isolation level repeatable read; A：开启事务并查询 B：开启事务，更新记录但不提交 A：查询 B：提交 A：查询 即使B修改了记录并提交，但是A两次的查询结果都是一样的，说明可以重复查询了。 B：新增记录 A：查询 并没有新增的数据，幻读问题也没有出现，因为我的MySQL用的是InnoDB作为存储引擎。 4. 将A的隔离级别设置为Serializable(可串行化)A：设置隔离级别，开启事务并查询 set session transaction isolation level serializable; B：开启事务，新增记录 发现卡住了，因为必须等A的事务执行完毕才行。 A：提交事务 B：插入记录成功。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[WINDOWS如何进入MySQL命令行]]></title>
      <url>%2FMySQL%2FMySQL%2FWINDOWS%E5%A6%82%E4%BD%95%E8%BF%9B%E5%85%A5MySQL%E5%91%BD%E4%BB%A4%E8%A1%8C%2F</url>
      <content type="text"><![CDATA[平时查看数据库都用工具Navicat for MySQL。 今天想通过命令行来实践一下MySQL的事务隔离性，发现竟然不知道怎么进入命令行，记录一下吧。 准备工作： 安装MySQL，配置环境变量，启动MySQL。这些不多说。 通过WIN+R打开CMD窗口 不知道为什么，git提供的黑窗口进不了MySQL命令行。 输入mysql -h127.0.0.1 -uroot -proot即可 -h后面是数据库连接的地址 -u后面是数据库的用户名 -p后面是数据库的密码 通过show databases;查看所有的库 命令都必须以;作为结尾 输入exit或通过快捷键Ctrl+C退出MySQL命令行]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[GROUP_CONCAT，GROUP BY结合使用]]></title>
      <url>%2FMySQL%2FMySQL%2FGROUP_CONCAT%EF%BC%8CGROUP%20BY%E7%BB%93%E5%90%88%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[今天做查询拼接的时候学习使用了GROUP_CONCAT。 统计各年龄段所有人员的名字，并放在一个字段内 1234567SELECT pv.age, GROUP_CONCAT(DISTINCT pv.patient_name) AS &apos;all_name&apos;FROM pv_patient_visit pvGROUP BY pv.age 因为用了GROUP BY,所以使用GROUP_CONCAT，而不是使用CONCAT。 因为名字可能重复，所以加上DISTINCT。 参考资料]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[COUNT,GROUP BY,CASE WHEN混用]]></title>
      <url>%2FMySQL%2FMySQL%2FCOUNT%2CGROUP%20BY%2CCASE%20WHEN%E6%B7%B7%E7%94%A8%2F</url>
      <content type="text"><![CDATA[今天在使用COUNT的时候学习了新的写法。 也就是COUNT结合CASE WHEN使用。 统计病人表不同年龄段各有多少人。 1234567SELECT pv.age, COUNT(pv.age) AS &apos;count&apos;FROM pv_patient_visit pvGROUP BY pv.age 统计病人表不同年龄段各有多少男人，女人。 12345678SELECT pv.age, COUNT(case when pv.sex=&apos;0&apos; then 1 else null end ) AS &apos;man&apos;, COUNT(case when pv.sex=&apos;1&apos; then 1 else null end ) AS &apos;woman&apos;FROM pv_patient_visit pvGROUP BY pv.age 后记COUNT( CASE WHEN pv.sex=&#39;0&#39; THEN 1 ELSE NULL END )这种写法，只适合表达式内字段属性很少的情况。比如是否删除，男女等。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Maven插件开发(1)]]></title>
      <url>%2FMaven%2FMaven%2FMaven%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91(1)%2F</url>
      <content type="text"><![CDATA[学习Maven插件的编写，有助于理解Maven的生命周期，goal，-D，-P参数等。 以一个Hello,World的例子来入门Maven插件的开发吧。 Maven插件本身也是Maven项目，所以我们先搭一个Maven项目的骨架出来。 先创建一个pom.xml文件12345678910111213141516171819202122232425 &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;sample.plugin&lt;/groupId&gt; &lt;artifactId&gt;hello-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;maven-plugin&lt;/packaging&gt; &lt;name&gt;Sample Maven Plugin&lt;/name&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.maven&lt;/groupId&gt; &lt;artifactId&gt;maven-plugin-api&lt;/artifactId&gt; &lt;version&gt;3.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.maven.plugin-tools&lt;/groupId&gt; &lt;artifactId&gt;maven-plugin-annotations&lt;/artifactId&gt; &lt;version&gt;3.4&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 指定这个sample项目的groupId，artifactId，version，packaging。加入该sample项目所需要依赖的jar包。 这里要注意的是，写一个Maven插件，packaging必须指定为maven-plugin。 artifactId最好是指定为xxxx-maven-plugin或者是maven-xxxx-plugin。这对后面执行这个插件有好处。 编写Java代码123456789101112131415161718package sample.plugin;import org.apache.maven.plugin.AbstractMojo;import org.apache.maven.plugin.MojoExecutionException;import org.apache.maven.plugin.MojoFailureException;import org.apache.maven.plugins.annotations.Mojo;/** * Says "Hi" to the user. */@Mojo(name = "sayhi")public class GreetingMojo extends AbstractMojo &#123; public void execute() throws MojoExecutionException, MojoFailureException &#123; getLog().info("Hello,world."); &#125;&#125; 抽象类AbstractMojo实现了接口Mojo和ContextEnabled，除了execute方法要我们自己实现外，其他的都可以直接使用。 @Mojo注解是必须要的，否则install插件的时候会失败。该注解用来控制在什么时候以何种方式来执行这个mojo。 execute方法可以抛出两个异常 MojoExecutionException，指的是非预期的异常。 MojoFailureException，指的是预期的异常。 安装插件 在pom.xml目录下，执行mvn clean install命令。 看到BUILD SUCCESS后，就可以在本地仓库里看到自己写的Maven插件了。 使用插件 我们在pom.xml里依赖一下新写的插件123456789&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;sample.plugin&lt;/groupId&gt; &lt;artifactId&gt;hello-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 依旧还是在pom.xml目录下，按下面的规则执行插件 mvn groupId:artifactId:version:goal 在刚写的sample项目里就是 mvn sample.plugin:hello-maven-plugin:1.0.0-SNAPSHOT:sayhi 可以看到屏幕上输出了Hello,world. 是不是执行命令太长，感觉这么写很烦，可以简写成mvn hello:sayhi。前提是你要遵循插件的artifactId指定为xxxx-maven-plugin或者是maven-xxxx-plugin。 结语本篇通过一个简单的demo来入门Maven插件，下次再写一些更实际的例子。 参考资料]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Linux熵池导致的Tomcat启动缓慢]]></title>
      <url>%2FTomcat%2FTomcat%2FLinux%E7%86%B5%E6%B1%A0%E5%AF%BC%E8%87%B4%E7%9A%84Tomcat%E5%90%AF%E5%8A%A8%E7%BC%93%E6%85%A2%2F</url>
      <content type="text"><![CDATA[在阿里云的Linux服务器下，启动一个项目，查看Log4J日志，显示项目已经启动完成。 但是页面在请求的时候，一直在等待响应，大概要等5分钟，才能响应成功。 这里记录一下解决的方法。 项目启动后，查看Tomcat目录/logs/catalina.out的日志。 发现 Server startup in 338255 ms 竟然花了338秒。 继续查看日志，发现大部分时间都花在了SessionIdGenerator这个类的createSecureRandom()方法上。 Mar 28, 2017 3:38:35 PM org.apache.catalina.util.SessionIdGenerator createSecureRandomINFO: Creation of SecureRandom instance for session ID generation using [SHA1PRNG] took [286,439] milliseconds. 大致意思是，Tomcat在生成sessionId的时候，用了叫做SHA1PRNG的算法，这个算法依赖于Linux下的熵池。 项目启动后，通过jstack pid &gt; log.txt命令，如下图，观察项目中线程的运行情况，也确实看到有线程在执行createSecureRandom()方法。PS：pid就是项目的进程id。jstack可能会提示无效的命令，这个时候就要到jdk/bin目录下去执行jstack命令了。 两种改法我试了第一种未生效，第二种生效了。 把%JAVA_HOME%/jre/lib/security/java.security下的 securerandom.source=file:/dev/random 改成 securerandom.source=file:/dev/./urandom 在启动参数中加上-Djava.security.egd=file:/dev/./urandom 如图，我在catalina.sh加上了这么一句。 效果 信息: Server startup in 37857 ms 生效后，查看catalina.out日志，发现花了37秒，相比设置前快了十倍。 题外话说点自己的理解，这里就不摘用很高深的术语了。 上面说到的优化方式在Tomcat的启动优化文档里也提到了。 其他的优化有去掉不必要的jar包依赖（Maven把scope设置成private）等等。 Log4J中的日志Log4J中显示的加载完成，只是Spring框架加载完成了。 我们知道Tomcat是一个Servlet容器，而生成sessionId是容器这块的。容器没加载完毕，就算Spring加载完毕，也是算没有启动完成的。 random和urandom的区别上面提到的第一种改法是把random改成了urandom。两个有什么区别呢？ 网上的结论是random更加安全，产生的是真正的随机数，而urandom是‘伪’随机数，可能没有random来的安全。 这些随机数是依赖噪声产生的，鼠标移动，键盘键入，I/O等就会产生噪声。 而为什么有urandom就变快了呢？这里就有个熵池的概念，SHA1PRNG算法根据熵池里的熵（我的理解熵就是随机数）来计算，random是阻塞的，也就是说使用random的时候，如果熵池空了，那就会阻塞线程至熵池里的熵够用为止。而urandom是非阻塞的。 为什么是/dev/./urandom据说是jdk的bug，如果不加/./的话，最后采用的还是random的。 关于熵池的补种除了上面提到的两种办法，还有一种办法就是使用工具来补种，也就是补充熵池，可以使用rng-tools工具。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[查看zookeeper节点的几种方式]]></title>
      <url>%2Fdubbo%2Fdubbo%2F%E6%9F%A5%E7%9C%8Bzookeeper%E8%8A%82%E7%82%B9%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[在使用dubbo的时候，有时候会报一个Please check registry access list (whitelist/blacklist)的异常。一般报这个错误就是说你在调用的这个服务找不到provider了。 这个时候如果想查看一个zookeeper上注册的节点有没有这个服务的话。有以下几种方式。 1. 直接通过命令行查看在Linux环境下，cd进入zookeeper的bin目录下，执行下面的命令 ./zkCli.sh -server 192.168.0.12:2181 成功后就会进入zookeeper的命令行了。如下图。 输入help可以查看有哪些命令 这里我们选用ls命令来查看节点。比如ls /dubbo/xx.xxx.xxxx/providers。这条命令会列出该路径下的所有节点。 如果要删除节点的话，就使用delete命令，比如delete /dubbo/xxx.xxx.xxxx/providers。用delete删除节点的时候，如果有子节点，必须先删除子节点，才能删除该节点。当然你也可以使用rmr来递归删除，不过挺危险的。 这种方式打印出来的节点是没有格式化过，全部挤在一起，完全看不了。而且节点是被encode过的，更加不美观。 2. 用Java程序遍历1234567891011121314151617181920212223242526272829303132import org.apache.zookeeper.WatchedEvent;import org.apache.zookeeper.Watcher;import org.apache.zookeeper.ZooKeeper;import java.net.URLDecoder;import java.util.List;public class Zoo &#123; private static final String connectString = "192.168.0.12:2181"; private static final int sessionTimeout = 2000; public static void main(String[] args) throws Exception &#123; String path = "/dubbo/xx.xxx.xxxx/providers"; ZooKeeper zk = new ZooKeeper(connectString, sessionTimeout, new Watcher() &#123; // 监控所有被触发的事件 public void process(WatchedEvent event) &#123; System.out.println("已经触发了" + event.getType() + "事件！"); &#125; &#125;); //获取路径下的节点 List&lt;String&gt; children = zk.getChildren(path, false); for (String pathCd : children) &#123; System.out.println(URLDecoder.decode(pathCd, "UTF-8")); //记得转码 &#125; &#125;&#125; 这种方式查看还行，但也挺麻烦。不过可以用这个来遍历删除节点。 3. 使用dubbokeeper使用开源项目dubbokeeper，有可视化界面。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Navicat for MySQL直接编辑Blob字段]]></title>
      <url>%2FMySQL%2FMySQL%2FNavicat%20for%20MySQL%E7%9B%B4%E6%8E%A5%E7%BC%96%E8%BE%91Blob%E5%AD%97%E6%AE%B5%2F</url>
      <content type="text"><![CDATA[今天项目中用到了Blob来存储数据，结果被中文乱码问题给坑了。 开发过程简化一下开发过程，如下。 1、建表并插入数据 先建了一张表，content字段使用Blob格式的。数据库都是UTF-8格式的。如下图，通过直接在Navicat for MySQL的备注里写入内容来新增一条基础数据。 2、生成POJO Java代码里对应库表的model如下。12345678910public class News &#123; private Integer id; private byte[] content; /** * 省略get/set */&#125; 3、查询数据库并打印 通过数据库连接，查询到这条数据。数据库连接里设置了UTF-8。代码直接简化成伪代码了。1234public static void main(String[] args) &#123; News news = new News(); //从数据库读取数据 System.out.println(new String(news.getContent()));&#125; 最后成功地在我的Win10上打印出了正确的中文。 出现乱码然后代码提交测试，基础数据从我本机导出到.sql文件，然后插入到测试数据库内（也都是UTF-8的）。发现在Linux机器下，打印出的中文是乱码。 做出了以下两点修改，解决了中文乱码的问题。 1、在byte数组转String的时候指定编码 将代码改成如下。1234public static void main(String[] args) throws Exception&#123; News news = new News(); //从数据库读取数据 System.out.println(new String(news.getContent(), "UTF-8"));&#125; 然后我的Win10也乱码了。线上也是乱码。问题并没有得到解决。 2、修改基础数据的维护方式 基础数据不直接在Navicat for MySQL编辑。 而是通过Java代码将String转成UTF-8编码格式的byte数组，然后插入到数据库中。 伪代码如下12345public static void main(String[] args) throws Exception&#123; News news = new News(); //新增一条记录 news.setContent(new String("中文", "UTF-8"); mapper.insert(news); //插入数据库&#125; 通过Java代码插入基础数据后，在Navicat for MySQL中查看。 如下图所示，Blob显示的内容为乱码 基础数据重新维护后，中文乱码问题解决。 本地和测试服务器的中文都显示正常了。 总结原因分析在Win10上的Navicat for MySQL通过备注查看Blob内容的时候，都是通过GBK格式的。 也就是说，如果直接在Navicat for MySQL通过备注直接编辑Blob的内容，并写入中文时，中文会被转码成GBK格式的二进制。 而我开始读取的时候读取的是GBK格式的二进制中文，然后我使用了new String(byte[] bytes)方法，由于忘了指定编码，所以JVM也使用了系统默认的GBK编码。所以开始的时候我的本地没有中文乱码问题的。而Linux系统默认编码不是GBK的，所以转码的时候出现了乱码。 然后我使用了new String(bytes, &quot;UTF-8&quot;)指定了用UTF-8来将字节码转换。由于数据库保存的Blob是GBK格式的，转成了UTF-8就出现了乱码，所以我本地也就出现了乱码问题。 最后我通过代码插入UTF-8的Blob数据到数据库，解决了乱码问题。 经验 不要直接在可视化工具里编辑含有Blob字段的库表。因为工具是无法确定编码的，工具帮你把中文转成blob的时候就有可能会有乱码问题。 Blob是无法指定编码的，因为里面存的是字节码，字符转字节码的过程要自己做，才能指定字符转字节的编码。不要在工具里做，这样才不会被坑。 编码一定要统一。要了解乱码的本质。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[$.post返回状态码200，但却进入error]]></title>
      <url>%2FJavaScript%2FJavaScript%2F%24.post%E8%BF%94%E5%9B%9E%E7%8A%B6%E6%80%81%E7%A0%81200%EF%BC%8C%E4%BD%86%E5%8D%B4%E8%BF%9B%E5%85%A5error%2F</url>
      <content type="text"><![CDATA[今天测试报了一个线上bug。 表现为：当有用户的时候没有bug，但是没有用户的时候，页面报错。 排查用简单的代码演示一下 js代码12345$.post(&quot;/xxx/xx/x&quot;, &#123;&quot;name&quot;:&quot;lxl&quot;&#125;, function (e) &#123; console.log(&apos;success&apos;)&#125;, &quot;json&quot;).error(function () &#123; console.log(&apos;error&apos;)&#125;); java代码1234567@RequestMapping(method = RequestMethod.POST, value = "/xxx/xx/x")public ResponseEntity&lt;List&lt;User&gt;&gt; PatientOrderListBySyuser(HttpServletRequest request, HttpServletResponse response, ModelMap model) &#123; //获取所有用户 List&lt;User&gt; list = userService.getUsers(); return new ResponseEntity&lt;List&lt;User&gt;&gt;(list, HttpStatus.OK);&#125; 过程重现后台list有数据的时候，可以进入$.post的success后台list没有数据的时候，进入的却是$.post的error后台返回的状态码都是200 debug 开始怀疑跨域问题，把处理跨域的filter注释掉，问题没有解决。 怀疑是dataType的问题，尝试把js代码里的dataType=json去掉，问题解决。 原来如此原来没有这个bug的时候，如果没有用户，返回的是空数组，可以被解析成json。 查看git提交记录，发现同事把没有用户的情况，改成返回null，然后不能被解析成json，所以进入error了。 结论后台返回null的时候，即使状态码是200，也不能进入dataType为json的ajax请求的success。 因为null无法解析为json格式，所以会进入error。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[git如何忽略不想提交的文件]]></title>
      <url>%2Fgit%2Fgit%2Fgit%E5%A6%82%E4%BD%95%E5%BF%BD%E7%95%A5%E4%B8%8D%E6%83%B3%E6%8F%90%E4%BA%A4%E7%9A%84%E6%96%87%E4%BB%B6%2F</url>
      <content type="text"><![CDATA[1. 在根目录下新建一个文件.gitignore这里应该会提示请键入文件名，可找人要一份。或按以下操作解决 1. 在项目根目录下面创建`gitignore.txt`文件 2. 把你需要排除的文件名保存到`gitignore.txt`文件 3. 在项目根目录下面按住Shift键并右键然后选择`在此处打开命令窗口` 4. 执行命令`ren gitignore.txt .gitignore` 2. 拷入以下内容123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238################### Eclipse#################*.pydevproject.project.metadatabin/tmp/*.tmp*.bak*.swp*~.niblocal.properties.classpath.settings/.loadpath# External tool builders.externalToolBuilders/# Locally stored &quot;Eclipse launch configurations&quot;*.launch# CDT-specific.cproject# PDT-specific.buildpath################### Visual Studio################### Ignore Visual Studio temporary files, build results, and## files generated by popular Visual Studio add-ons.# User-specific files*.suo*.user*.sln.docstates# Build results[Dd]ebug/[Rr]elease/x64/build/[Bb]in/[Oo]bj/# MSTest test Results[Tt]est[Rr]esult*/[Bb]uild[Ll]og.**_i.c*_p.c*.ilk*.meta*.obj*.pch*.pdb*.pgc*.pgd*.rsp*.sbr*.tlb*.tli*.tlh*.tmp*.tmp_proj*.log*.vspscc*.vssscc.builds*.pidb*.log*.scc# Visual C++ cache filesipch/*.aps*.ncb*.opensdf*.sdf*.cachefile# Visual Studio profiler*.psess*.vsp*.vspx# Guidance Automation Toolkit*.gpState# ReSharper is a .NET coding add-in_ReSharper*/*.[Rr]e[Ss]harper# TeamCity is a build add-in_TeamCity*# DotCover is a Code Coverage Tool*.dotCover# NCrunch*.ncrunch*.*crunch*.local.xml# Installshield output folder[Ee]xpress/# DocProject is a documentation generator add-inDocProject/buildhelp/DocProject/Help/*.HxTDocProject/Help/*.HxCDocProject/Help/*.hhcDocProject/Help/*.hhkDocProject/Help/*.hhpDocProject/Help/Html2DocProject/Help/html# Click-Once directorypublish/# Publish Web Output*.Publish.xml*.pubxml*.publishproj# NuGet Packages Directory## TODO: If you have NuGet Package Restore enabled, uncomment the next line#packages/# Windows Azure Build Outputcsx*.build.csdef# Windows Store app package directoryAppPackages/# Otherssql/*.CacheClientBin/[Ss]tyle[Cc]op.*~$**~*.dbmdl*.[Pp]ublish.xml*.pfx*.publishsettings# RIA/Silverlight projectsGenerated_Code/# Backup &amp; report files from converting an old project file to a newer# Visual Studio version. Backup files are not needed, because we have git ;-)_UpgradeReport_Files/Backup*/UpgradeLog*.XMLUpgradeLog*.htm# SQL Server filesApp_Data/*.mdfApp_Data/*.ldf############### Windows detritus############## Windows image file cachesThumbs.dbehthumbs.db# Folder config fileDesktop.ini# Recycle Bin used on file shares$RECYCLE.BIN/# Mac crap.DS_Store############### Python#############*.py[cod]# Packages*.egg*.egg-infodist/build/eggs/parts/var/sdist/develop-eggs/.installed.cfg# Installer logspip-log.txt# Unit test / coverage reports.coverage.tox#Translations*.mo#Mr Developer.mr.developer.cfg################### idea#################*.iml.idea/################### maven#################target/*.war################### dev#################web/pt_zsyy-model/.checkstyledev/web/pt_zsyy/.springWebflowweb_sql/database.properties 3. 提交.gitignore题外话 使用.gitkeepGit会忽略空的文件夹。如果你想版本控制包括空文件夹，根据惯例会在空文件夹下放置.gitkeep文件。其实对文件名没有特定的要求。一旦一个空文件夹下有文件后，这个文件夹就会在版本控制范围内。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Spring配置欢迎页引发的思考]]></title>
      <url>%2FSpring%2FSpring%2FSpring%E9%85%8D%E7%BD%AE%E6%AC%A2%E8%BF%8E%E9%A1%B5%E5%BC%95%E5%8F%91%E7%9A%84%E6%80%9D%E8%80%83%2F</url>
      <content type="text"><![CDATA[引言今天下载了一个demo项目，跑起来可以默认打开index.jsp的欢迎页。但是把index.jsp换成index.html就会404。平时也没配置过欢迎页，就顺手研究了一下。于是就查漏补缺了以下知识点。 项目概述 项目中的web.xml 123456789&lt;servlet&gt; &lt;servlet-name&gt;mvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;mvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 项目的web.xml里没有配置&lt;welcome-file-list&gt; 知识点viewResolver开始我以为是这个bean的问题，因为我看到这个bean的配置里有个.jsp，后来才知道这个bean是在请求处理完以后，返回ModelAndView，把数据渲染到页面里用的。 三种index.html可行的方法 使用标签&lt;mvc:default-servlet-handler/&gt; 在xxxx-servlet.xml里定义这个标签。这个标签的作用是，当返回404的时候，就使用默认的servlet去处理这个请求。所以当使用index.html的时候，先经过DispatcherServlet，发现没有对用的handler，于是返回404，然后被默认的servlet处理，成功显示index.html的内容。 使用这个标签的时候，务必加上&lt;context:annotation-config /&gt;，不然就会发现普通的请求过不了了。原因可以参考这里 使用标签&lt;mvc:resource mapping=&quot;xx&quot; location=&quot;&quot;/&gt; 在xxxx-servlet.xml里定义这个标签。这个标签的作用是，当访问的是静态资源的时候，并且被mapping匹配到的话，都会把位置定位到相对路径location下。 定义一个使用default的servlet-mapping 1234&lt;servlet-mapping&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;url-pattern&gt;*.html&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 在项目的web.xml里加上这段代码也可以实现。因为index.html直接就匹配了default的servlet了。 /和/*的区别如果我把DispatcherServlet的匹配路径从/改成/*，就会发现连index.jsp也404了。这是为什么呢？ /*会匹配所有请求，如果请求没被其他servlet匹配走，那就都会走这个servlet，这种写法不是很推荐。还有个比较神奇的问题就是，当写成/*的时候，就不会去默认访问&lt;welcome-file-list&gt;里的欢迎页了。只有在访问的时候手动输入欢迎页的请求地址才能打开。 /呢，就是一个请求进来以后，所有的servlet都不匹配。就会通过/的servlet来实现。这种写法也不是很推荐的。 这里就要说到&lt;url-pattern&gt;的匹配优先级问题了。 &lt;url-pattern&gt;的匹配优先级精确路径&gt;最长路径&gt;扩展名 精确路径：类似&lt;url-pattern&gt;/demo.html&lt;/url-pattern&gt; 路径匹配：类似&lt;url-pattern&gt;/xxx/xx/x/*&lt;/url-pattern&gt; 扩展名匹配：类似&lt;url-pattern&gt;*.jsp&lt;/url-pattern&gt; 路径匹配和扩展名匹配是不能同时使用的。比如&lt;url-pattern&gt;/*.jsp&lt;/url-pattern&gt;就是一种错误的用法。 相同的&lt;url-pattern&gt;的问题在同一个web.xml内，是不允许使用一样的&lt;url-pattern&gt;，否则编译也不会通过。 但是Tomcat的web.xml和项目里的web.xml如果定义了相同的&lt;url-pattern&gt;是可以的，如果发生这种情况，那么会匹配项目里的&lt;url-pattern&gt;。 如果Tomcat的web.xml和项目的web.xml里都配置&lt;welcome-file-list&gt;了的话，那只有项目里的会生效，而不是把两个&lt;welcome-file-list&gt;合并起来。 结论先说这个项目的index.jsp是怎么实现欢迎页的因为Tomcat的web.xml里配置了12345&lt;welcome-file-list&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt;&lt;/welcome-file-list&gt; 当访问http://127.0.0.1:8080的时候，就会默认加上后缀，也就是会请求http://127.0.0.1:8080/index.html，如果404的话，就请求http://127.0.0.1:8080/index.htm，以此类推。 如果项目的web.xml里也配置&lt;welcome-file-list&gt;标签的话，Tomcat里的会被覆盖。 当请求http://127.0.0.1:8080/index.jsp的时候，因为匹配了定义在Tomcat的web.xml里的处理jsp的Servlet，所以显示成功了。 为什么把index.jsp换成index.html就不行了呢？因为http://127.0.0.1:8080/index.html匹配的是DispatcherServlet，而controller里找不到对应的handler，所以报错404了。 结语可能点比较多，描述的比较乱，其实弄清楚&lt;url-pattern&gt;的匹配优先级就基本能理解为什么index.html默认是不行的了。然后知道Tomcat的web.xml里有个处理jsp的jsp-servlet，和一个名叫default的可以处理静态资源的servlet就行了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[引用计数算法和根搜索算法]]></title>
      <url>%2FJVM%2FJVM%2F%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E7%AE%97%E6%B3%95%E5%92%8C%E6%A0%B9%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%2F</url>
      <content type="text"><![CDATA[要判断JVM中哪些对象是可以被回收的。有两种算法，一起了解一下。 引用计数算法实现方式给一个对象添加一个引用计数器，每当有一个地方引用它时，则引用计数器+1，当引用失效的时候-1。当减到0的时候，则说明该对象可以被回收了。 这个算法有个致命的缺陷，当有循环引用的时候就不行了。如下图，如果用引用计数算法，则这两个对象都不会被GC回收了。所以Java使用的是根搜索算法。 根搜索算法实现方法指定一系列的叫做“GC Roots”的对象，以这些对象作为起点往下遍历搜索，当有对象不在搜索的路径上的时候，也就是不可达的时候，则说明它该被回收了。 比如下图的Object2,3,4因为在搜索路径上，是可达的，所以不会被GC回收。而Object5,6,7虽然有互相引用，但是不在根搜索的路径上，是不可达的，所以会被GC视为可回收对象。 GC Roots那么哪些对象是GC Roots对象呢？ 虚拟机栈（栈帧中的本地变量表）中的引用的对象。 方法区的类静态属性引用的对象。 方法区的常量引用的对象。 本地方法栈中JNI（即Native方法）的引用的对象。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[反编译i++]]></title>
      <url>%2FJVM%2FJVM%2F%E5%8F%8D%E7%BC%96%E8%AF%91i%2B%2B%2F</url>
      <content type="text"><![CDATA[通过反编译来研究一下java的指令集 i = i++1234567public class Test &#123; public static void main(String... args) &#123; int i = 0; i = i++; System.out.println(i); //0 &#125;&#125; 使用javac编译后再使用javap -c Test反编译这个类查看它的字节码，如下（只摘取main方法）：1234567891011public static void main(java.lang.String[]);Code:0: iconst_01: istore_12: iload_13: iinc 1, 16: istore_17: getstatic #2; //Field java/lang/System.out:Ljava/io/PrintStream;10: iload_111: invokevirtual #3; //Method java/io/PrintStream.println:(I)V14: return 这里，我从第0行开始分析（分析中【】表示栈，栈的底端在左边，顶端在右边）： 0：将常数0压入栈，栈内容：【0】 1：将栈顶的元素弹出，也就是0，保存到局部变量区索引为为1（也就是变量i）的地方。栈内容：【】 2：将局部变量区索引为1（也就是变量i）的值压入栈，栈内容：【0】 3：将局部变量区索引为1（也就是常量i）的值加一，此时局部变量区索引为1的值（也就是i的值）是1。栈内容：【0】 6：将栈顶元素弹出，保存到局部变量区索引为1（也就是i）的地方，此时i又变成了0。栈内容：【】 7：获取常量池中索引为2所表示的类变量，也就是System.out。栈元素：【】 10：将局部变量区索引为1的值（也就是i）压入栈。栈元素：【0】 11：调用常量池索引为3的方法，也就是System.out.println 14：返回main方法 i = ++i1234567public class Test &#123; public static void main(String... args) &#123; int i = 0; i = ++i; System.out.println(i); //1 &#125;&#125; 同样javap -c Test1234567891011public static void main(java.lang.String...); Code: 0: iconst_0 //0入栈，【0】 1: istore_1 //栈顶出栈，并赋值给索引为1的变量，【】 2: iinc 1, 1 //索引为1的变量+1，【】 5: iload_1 //索引为1的变量入栈，【1】 6: istore_1 //栈顶出栈，并赋值给索引为1的变量，【】 7: getstatic #2 // Field java/lang/System.out:Ljava/io/PrintStream; 10: iload_1 11: invokevirtual #3 // Method java/io/PrintStream.println:(I)V 14: return i = i++ + ++i1234567public class Test &#123; public static void main(String... args) &#123; int i = 0; i = i++ + ++i; System.out.println(i); //2 &#125;&#125; 同样javap -c Test1234567891011121314public static void main(java.lang.String...); Code: 0: iconst_0 //0入栈，【0】 1: istore_1 //栈顶出栈，并赋值给索引为1的变量，【】 2: iload_1 //索引为1的变量入栈，【0】 3: iinc 1, 1 //索引为1的变量+1，【0】 6: iinc 1, 1 //索引为1的变量+1，【0】 9: iload_1 //索引为1的变量入栈，【0|2】 10: iadd //栈顶的两个整型相加并入栈，【2】 11: istore_1 //栈顶出栈，并赋值给索引为1的变量，【】 12: getstatic #2 // Field java/lang/System.out:Ljava/io/PrintStream; 15: iload_1 16: invokevirtual #3 // Method java/io/PrintStream.println:(I)V 19: return 通过图片理解指令int a = 100; int b = 98; int c = a+b;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[重定向和转发的区别]]></title>
      <url>%2FTomcat%2FTomcat%2F%E9%87%8D%E5%AE%9A%E5%90%91%E5%92%8C%E8%BD%AC%E5%8F%91%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
      <content type="text"><![CDATA[说起重定向和转发，可能好多人的第一印象就是重定向的浏览器地址会变，而转发的不会变。下面说说为什么会这样。 重定向Tomcat7用的是servlet-api的3.0版本，文档如下 查看源码可以知道，重定向的时候，服务端会向客户端发送一个302的状态码（用这个可以劫持URL），还有一个重定向的地址，然后客户端会请求这个重定向的地址。所以造成了浏览器的地址变化。 而在重定向完的代码中，有个finally代码块，会清空request里的值。所以重定向是不能用上一次的request里的数据的。 转发1request.getRequestDispatcher(&quot;/xx/xxx/xxx.jsp&quot;).forward(request,response); 转发是直接在服务器完成的，所以转发以后是可以使用上一次的request里的数据的。当然在转发完成以后生成响应的时候也会清空request，但是已经使用好并返回客户端了，清空也无所谓了。 区别 重定向是在客户端完成的，转发是在服务端完成的。 重定向会丢失request里的parameter和attribute，转发不会。 重定向相当于客户端请求了两次，而转发只请求了一次。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java的内部类--匿名内部类【3】]]></title>
      <url>%2FJava%E5%9F%BA%E7%A1%80%2Fjava%E5%9F%BA%E7%A1%80%2F%E5%86%85%E9%83%A8%E7%B1%BB%2Fjava%E7%9A%84%E5%86%85%E9%83%A8%E7%B1%BB--%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E3%80%903%E3%80%91%2F</url>
      <content type="text"><![CDATA[匿名内部类也就是没有名字的内部类 正因为没有名字，所以匿名内部类只能使用一次，它通常用来简化代码编写 但使用匿名内部类还有个前提条件：必须继承一个父类或实现一个接口 实例1:不使用匿名内部类来实现抽象方法12345678910111213141516abstract class Person &#123; public abstract void eat();&#125; class Child extends Person &#123; public void eat() &#123; System.out.println("eat something"); &#125;&#125; public class Demo &#123; public static void main(String[] args) &#123; Person p = new Child(); p.eat(); &#125;&#125; 运行结果： eat something 可以看到，我们用Child继承了Person类，然后实现了Child的一个实例，将其向上转型为Person类的引用 但是，如果此处的Child类只使用一次，那么将其编写为独立的一个类岂不是很麻烦？ 这个时候就引入了匿名内部类 实例2：匿名内部类的基本实现1234567891011121314abstract class Person &#123; public abstract void eat();&#125; public class Demo &#123; public static void main(String[] args) &#123; Person p = new Person() &#123; public void eat() &#123; System.out.println("eat something"); &#125; &#125;; p.eat(); &#125;&#125; 运行结果： eat something 可以看到，我们直接将抽象类Person中的方法在大括号中实现了 这样便可以省略一个类的书写 并且，匿名内部类还能用于接口上 实例3：在接口上使用匿名内部类123456789101112131415interface Person &#123; public void eat();&#125; public class Demo &#123; public static void main(String[] args) &#123; Person p = new Person() &#123; public void eat() &#123; System.out.println("eat something"); &#125; &#125;; p.eat(); &#125;&#125; 由上面的例子可以看出，只要一个类是抽象的或是一个接口，那么其子类中的方法都可以使用匿名内部类来实现 最常用的情况就是在多线程的实现上，因为要实现多线程必须继承Thread类或是继承Runnable接口 实例4：在匿名内部类中自定义方法1234567891011121314public class InnerClassDemo06 &#123; public static void main(String[] args) &#123; new Thread()&#123; @Override public void run() &#123; get(); &#125; private void get()&#123; System.out.println(111); &#125; &#125;.get(); &#125;&#125; 运行结果： 111 可以看到可以定义自己的方法，并且就算是private的方法也可以访问到。但是别向上转型，即Thread t = new Thread(){};因为Thread里并没有get()方法。 总结 匿名内部类必须是基于一个抽象类或接口的。 匿名内部类是可以定义其他方法的。 匿名内部类是局部内部类的一种，所以局部内部类的所有限制都对其生效。 匿名内部类不能有static的变量，方法。 匿名内部类不能有构造方法，但是可以通过构造块{}来初始化。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java的内部类--局部内部类【2】]]></title>
      <url>%2FJava%E5%9F%BA%E7%A1%80%2Fjava%E5%9F%BA%E7%A1%80%2F%E5%86%85%E9%83%A8%E7%B1%BB%2Fjava%E7%9A%84%E5%86%85%E9%83%A8%E7%B1%BB--%E5%B1%80%E9%83%A8%E5%86%85%E9%83%A8%E7%B1%BB%E3%80%902%E3%80%91%2F</url>
      <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435363738public class InnerClassDemo05 &#123; public static void main(String[] args) &#123; new Outer05().printLocalClass(true); &#125;&#125;class Outer05 &#123; private String outerClassName = "Outer05"; public void printLocalClass(final boolean isPrintOuterClassName) &#123; //局部内部类前面不能有任何访问修饰符 class LocalClass implements Runnable &#123; private String localClassName = "localClass"; public void run() &#123; while (true) &#123; try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; /** * 局部内部类可以访问外部类域和局部变量，局部变量必须是final类型的 */ if (isPrintOuterClassName) &#123; System.out.println(outerClassName + " " + localClassName); &#125; else &#123; System.out.println(localClassName); &#125; &#125; &#125; &#125; new Thread(new LocalClass()).start(); &#125;&#125; 为什么方法一结束，程序还在不停的输出呢。我们用javap -private Outer05\$1LocalClass.class来反编译看看我们看到了创建了一个局部变量的副本。并且这个副本会被当作参数传入局部内部类的构造方法中。为什么要final类型的局部变量呢？（在java8里面可以省略不写final）因为外部方法随时会结束掉，而内部类如果引用了局部变量，那不就出错了嘛。所以内部类创建了一个副本，而假设局部变量如果改变了的话，内部类的变量没变（副本），那用户不是很迷惑，所以要统一就用final。（不过改变引用对象内部的值那也是没办法统一的。。比如改变数组里的某个值）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java的内部类--成员内部类【1】]]></title>
      <url>%2FJava%E5%9F%BA%E7%A1%80%2Fjava%E5%9F%BA%E7%A1%80%2F%E5%86%85%E9%83%A8%E7%B1%BB%2Fjava%E7%9A%84%E5%86%85%E9%83%A8%E7%B1%BB--%E6%88%90%E5%91%98%E5%86%85%E9%83%A8%E7%B1%BB%E3%80%901%E3%80%91%2F</url>
      <content type="text"><![CDATA[例子一123456789101112131415161718192021222324252627282930313233public class InnerClassDemo01 &#123; public static void main(String[] args) &#123; OuterClass.InnerClass innerClass = new OuterClass().new InnerClass(); innerClass.print(); new Thread(innerClass).start(); &#125;&#125;class OuterClass &#123; private String name; public String getName() &#123; return name; &#125; public class InnerClass implements Runnable &#123; public InnerClass() &#123; name = "lxl"; //注意不要用this.name，this指的是内部类的。 &#125; public void run() &#123; System.out.println(name); &#125; public void print() &#123; System.out.println(getName()); &#125; &#125;&#125; 这个例子可以学到： 内部类可以随意的使用外部类的属性或方法。即使是private的。 如何获取成员内部类的实例，即：OuterClass.InnerClass innerClass = new OuterClass().new InnerClass()。 内部类也是可以继承或实现接口的。 例子二123456789101112131415161718public class InnerClassDemo02 &#123; public static void main(String[] args) &#123; new OuterClass02().new InnerClass02(); //编译报错 &#125;&#125;class OuterClass02 &#123; private class InnerClass02 &#123; static &#123; //编译报错 &#125; &#125; public OuterClass02 ()&#123; new InnerClass02(); &#125;&#125; 这个例子可以学到： 成员内部类和方法还有变量一样，也是被访问修饰符所限制住的。 我试着在外部类加了个get方法，返回一个内部类的实例。但是返回了实例发现也调用不了内部类的public方法。而且声明一个内部类也是报错的。 成员内部类里不能有static的属性，方法，静态块。 例子三12345678910111213141516171819202122public class InnerClassDemo03 &#123; public static void main(String[] args) &#123; OuterClass03 outer = new OuterClass03(); OuterClass03.InnerClass03 inner = outer.new InnerClass03(); System.out.println(outer == inner.getOuterClass()); //true System.out.println(outer == inner.getNewOuterClass()); //false &#125;&#125;class OuterClass03 &#123; public class InnerClass03 &#123; //获取外部类的引用 public OuterClass03 getOuterClass() &#123; return OuterClass03.this; &#125; public OuterClass03 getNewOuterClass() &#123; return new OuterClass03(); &#125; &#125;&#125; 这个例子可以学到： 如何获取当前外部类的引用，貌似没什么卵用。补充：在ArrayList的源码中看到，迭代器使用了内部类，并且通过1234567## 例子四我们已经知道如何获取一个内部类的实例```javapublic static void main(String[] args) &#123; new OuterClass().new InnerClass();&#125; 来看下反编译以后的代码12345public static void main(String[] args) &#123; OuterClass var10002 = new OuterClass(); var10002.getClass(); new InnerClass(var10002);&#125; 由于没有声明外部类的名字，所以反编译出来的名字是java生成的。 可以看到内部类其实是拿到了外部类的引用的。所以内部类可以轻松的访问到外部类的方法和属性。 例子五123456789101112131415161718192021222324252627public class InnerClassDemo04 &#123; public static void main(String[] args) &#123; new OuterClass04(); &#125;&#125;class OuterClass04 &#123; private String name; //定义个内部类 public class InnerClass04 &#123; private String name; private void print() &#123; System.out.println(name); &#125; &#125; public OuterClass04() &#123; InnerClass04 innerClass = new InnerClass04(); innerClass.name = "lxl"; innerClass.print(); //输出：lxl &#125;&#125; 这个例子可以学到： 外部类要调用内部类的方法就必须要拿到一个内部类的实例。而且外部类可以调用内部类的private方法。 在外部类里声明内部类可以省略外部类的类名，java会自动加上。 内部类的属性可以和外部类的属性重名，java会默认加上this . name，如果想用父类的那个，就可以用例子三了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Nginx+重定向导致的问题]]></title>
      <url>%2FTomcat%2FTomcat%2FNginx%2B%E9%87%8D%E5%AE%9A%E5%90%91%E5%AF%BC%E8%87%B4%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
      <content type="text"><![CDATA[场景描述在做项目迁移的时候，有个bug是页面跳转以后显示不出来： 1response.sendRedirect("/xxx/xxx.htm?action=xxx"); 原因是虽然Nginx设置了https的协议，但是根据下面的图片来看，response.sendRedirect()以后请求被重定向到http上了。 查了资料 解决方法： 找运维人员nginx配置： 1234proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; 在tomcat的server.xml里的Engine模块下加入： 1&lt;Valve className=&quot;org.apache.catalina.valves.RemoteIpValve&quot; protocolHeader=&quot;X-Forwarded-Proto&quot; /&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java的内部类]]></title>
      <url>%2FJava%E5%9F%BA%E7%A1%80%2Fjava%E5%9F%BA%E7%A1%80%2F%E5%86%85%E9%83%A8%E7%B1%BB%2Fjava%E7%9A%84%E5%86%85%E9%83%A8%E7%B1%BB%2F</url>
      <content type="text"><![CDATA[内部类的分类如下，逐一分析。java的内部类–成员内部类【1】 java的内部类–局部内部类【2】 java的内部类–匿名内部类【3】 java的内部类–静态内部类【4】 通过反射分析内部类【5】]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java的内部类--静态内部类【4】]]></title>
      <url>%2FJava%E5%9F%BA%E7%A1%80%2Fjava%E5%9F%BA%E7%A1%80%2F%E5%86%85%E9%83%A8%E7%B1%BB%2Fjava%E7%9A%84%E5%86%85%E9%83%A8%E7%B1%BB--%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB%E3%80%904%E3%80%91%2F</url>
      <content type="text"><![CDATA[静态内部类和成员内部类差不多。1234567891011121314public class InnerClassDemo07 &#123; public static void main(String[] args) &#123; Outer07.Inner07 inner07 = new Outer07.Inner07(); &#125;&#125;class Outer07 &#123; static class Inner07 &#123; public Inner07() &#123; System.out.println("init"); &#125; &#125;&#125; 总结 静态内部类只能访问外部类的静态方法或变量 静态内部类的创建形式是：OuterClass.InnerClass inner = new OuterClass.InnerClass()]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[通过反射分析内部类【5】]]></title>
      <url>%2FJava%E5%9F%BA%E7%A1%80%2Fjava%E5%9F%BA%E7%A1%80%2F%E5%86%85%E9%83%A8%E7%B1%BB%2F%E9%80%9A%E8%BF%87%E5%8F%8D%E5%B0%84%E5%88%86%E6%9E%90%E5%86%85%E9%83%A8%E7%B1%BB%E3%80%905%E3%80%91%2F</url>
      <content type="text"><![CDATA[从成员内部类那篇教程里我们知道，内部类是可以拿到外部类的引用的，所以可以直接访问外部类的域，方法。 但是拿到了引用为什么能访问private类型的域或方法呢。我们用反射来打印下面这个外部类。123456789101112public class InnerClassDemo08 &#123; private String name; public class InnerClass &#123; public InnerClass() &#123; name = "lxl"; &#125; &#125;&#125; 得到结果 1234567public class cn.java.learning.innerclass.InnerClassDemo08&#123; private java.lang.String name; public cn.java.learning.innerclass.InnerClassDemo08(); static java.lang.String access$002(cn.java.learning.innerclass.InnerClassDemo08, java.lang.String);&#125; 可以看到有个隐藏的静态方法叫access$002，所以可以访问。每次调用外部类的域或方法，相当于是执行了方法access$002(外部类的引用) 反射的类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118public class ReflectionTest &#123; public static void main(String[] args) &#123; String className = "cn.java.learning.innerclass.InnerClassDemo08"; StringBuffer sb = new StringBuffer(); try &#123; Class cl = Class.forName(className); Class superCl = cl.getSuperclass(); sb. append(Modifier.toString(cl.getModifiers())). append(" class "). append(cl.getName()); if(superCl!=null&amp;superCl!= Object.class)&#123; sb.append(" extends ").append(superCl.getName()); &#125; sb.append("&#123;"); System.out.println(sb); ReflectionTest.printFields(cl); System.out.println(); ReflectionTest.printConstructors(cl); System.out.println(); ReflectionTest.printMethods(cl); System.out.println(); System.out.println("&#125;"); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; /** * 打印一个类的所有构造方法 * * @param cl 目标类 */ public static void printConstructors(Class cl) &#123; Constructor[] constructors = cl.getConstructors(); StringBuffer sb = new StringBuffer(); for (Constructor c : constructors) &#123; sb.append(" "); //缩进一个tab键的距离 String modifiers = Modifier.toString(c.getModifiers()); if (modifiers.length() &gt; 0) &#123; sb.append(modifiers).append(" "); //输出访问修饰符 &#125; sb.append(c.getName()).append("("); //输出类名 Class[] paramTypes = c.getParameterTypes(); for (int i = 0; i &lt; paramTypes.length; i++) &#123; if (i &gt; 0) &#123; sb.append(", "); &#125; sb.append(paramTypes[i].getName()); //输出形参的类型 &#125; sb.append(");"); System.out.println(sb); sb.delete(0, sb.length()); //清空 &#125; &#125; /** * 打印一个类的所有方法 * * @param cl 目标类 */ public static void printMethods(Class cl) &#123; Method[] methods = cl.getDeclaredMethods(); StringBuffer sb = new StringBuffer(); for (Method m : methods) &#123; sb. append(" "). append(Modifier.toString(m.getModifiers())). append(" "). append(m.getReturnType().getName()). append(" "). append(m.getName()). append("("); Class[] paramTypes = m.getParameterTypes(); for (int i = 0; i &lt; paramTypes.length; i++) &#123; if (i &gt; 0) &#123; sb.append(", "); &#125; sb.append(paramTypes[i].getName()); //输出形参的类型 &#125; sb.append(");"); System.out.println(sb); sb.delete(0, sb.length()); //清空 &#125; &#125; /** * 打印一个类中的所有域 * * @param cl 目标类 */ public static void printFields(Class cl) &#123; Field[] fields = cl.getDeclaredFields(); StringBuffer sb = new StringBuffer(); for (Field f : fields) &#123; sb. append(" "). append(Modifier.toString(f.getModifiers())). append(" "). append(f.getType().getName()). append(" "). append(f.getName()). append(";"); System.out.println(sb); sb.delete(0, sb.length()); //清空 &#125; &#125;&#125; 也可以通过javap命令来反编译.class文件直接得到结果javap -private className.calss]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[git在push的时候显示the remote end hung up的解决办法 long的解决办法]]></title>
      <url>%2Fgit%2Fgit%2Fgit%E5%9C%A8push%E7%9A%84%E6%97%B6%E5%80%99%E6%98%BE%E7%A4%BAthe%20remote%20end%20hung%20up%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%2F</url>
      <content type="text"><![CDATA[今天在家华数网push的时候，一会提示 fatal: Could not read from remote repository 一会提示 The remote end hung up unexpectedly 就是push不成功。开始还以为是家里电脑没配好github的公钥。 但是可以pull成功的，排除这种可能。 后来尝试只修改一点点文件，发现可以push成功。 解决方法最后发现是华数网太坑了。。网速贼慢导致的push失败。。因为博客生成的静态文件太多，网速又慢，相当于git提交超时了。。略微设置一下就解决了这个问题了。 在git bash里运行这两句命令即可。123git config --global http.lowSpeedLimit 0git config --global http.lowSpeedTime 999999 单位都是秒。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[git clone的时候显示Filename too long的解决办法]]></title>
      <url>%2Fgit%2Fgit%2Fgit%20clone%E7%9A%84%E6%97%B6%E5%80%99%E6%98%BE%E7%A4%BAFilename%20too%20long%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%2F</url>
      <content type="text"><![CDATA[在Git bash中，运行下列命令即可：1git config --global core.longpaths true 如果只想对本次clone有效，只要在上述命令中去掉--global即可。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java设计模式--单例模式]]></title>
      <url>%2FJava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2FJava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2FJava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F--%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[单例模式介绍使用单例可以减少不必要的系统开销，比如Spring里配置的数据源，创建和销毁耗费大量的资源，所以就用单例来保证项目加载的时候只生成一个实例，大家公用该实例。Spring的bean默认都是Singleton的。 单例模式有以下特点： 单例类只能有一个实例。 单例类必须自己创建自己的唯一实例。 单例类必须给所有其他对象提供这一实例。 单例模式的写法我画了张图来总结一下我所知道的单例模式的写法。 具体代码演示 懒汉式12345678910111213141516public class SingletonDemo01 &#123; private static SingletonDemo01 instance = null; private SingletonDemo01() &#123; &#125; public static SingletonDemo01 getInstance() &#123; if (instance == null) &#123; instance = new SingletonDemo01(); &#125; return instance; &#125;&#125; 这个有线程安全问题：线程A判断完实例没有创建，刚刚准备创建对象的时候，时间片切换到第二个线程B，这个时候线程B也发现实例没有创建，然后两个线程就各创建了一个对象了。 饿汉式12345678910111213public class SingletonDemo02 &#123; private static SingletonDemo02 instance = new SingletonDemo02(); private SingletonDemo02() &#123; //设置私有构造外部就不能通过new来新建实例了。 &#125; public static SingletonDemo02 getInstance() &#123; return instance; &#125;&#125; 优点： 饿汉模式简单，也没有线程安全问题。 了解过类加载机制的同学可能要问，如果线程A和线程B同时触发了类加载机制怎么办呢？会不会在线程切换间创建两个对象？没关系，在jvm里，类加载的时候会自动的加锁，并且有CAS保证了只有一个对象被创建。具体细节这里不展开。 缺点： 如果我的类里定义了其他静态方法或静态变量，我只是想用一下静态方法或变量，依据getstatic指令触发类的初始化，这个时候，instance变量会跟着一起初始化，也就创建了一个SingletonDemo02的对象，白白浪费了内存。 单检锁12345678910111213141516public class SingletonDemo03 &#123; private static SingletonDemo03 instance = null; private SingletonDemo03() &#123; &#125; public synchronized static SingletonDemo03 getInstance() &#123; if (instance == null) &#123; instance = new SingletonDemo03(); &#125; return instance; &#125;&#125; 优点: 线程安全。 在懒汉式上加上了synchronized关键字，也就解决了普通懒汉式线程不安全的问题。 缺点： 锁的粒度太粗，instance==null的判断并不需要加锁。 双检锁1234567891011121314151617181920public class SingletonDemo04 &#123; private static volatile SingletonDemo04 instance = null; private SingletonDemo04() &#123; &#125; public synchronized static SingletonDemo04 getInstance() &#123; if (instance == null) &#123; synchronized (SingletonDemo04.class) &#123; if (instance == null) &#123; instance = new SingletonDemo04(); &#125; &#125; &#125; return instance; &#125;&#125; jvm创建对象的时候大致干三件事： 在堆上分配内存空间 执行类的构造方法初始化参数 把创建的对象指向分配的内存空间地址 在编译优化里，这几步的执行顺序并不是一定的，可能是123，也可能是132。 这里的volatile是为了防止132运行的时候，别的线程发现对象不为null，然后直接去操作对象里的某些参数。 优点: 线程安全，锁的粒度小 缺点： 多线程学的不扎实的可能很难理解。 静态内部类123456789101112131415public class SingletonDemo05 &#123; private SingletonDemo05() &#123; &#125; private static final class SingletonManager &#123; private static SingletonDemo05 instance = new SingletonDemo05(); &#125; public static SingletonDemo05 getInstance() &#123; return SingletonManager.instance; &#125;&#125; 优点: 改进了饿汉式的缺点，可以发现，现在即使SingletonDemo05里有其他的静态方法，只要我不调用getInstance()方法，我就不会白白的创建一个对象了。 枚举123456789101112131415161718public enum SingletonDemo06 &#123; INSTANCE; private Resource instance; SingletonDemo06() &#123; instance = new Resource(); &#125; public Resource getInstance() &#123; return instance; &#125;&#125;class Resource &#123;&#125; 优点： 前面的几种方式都可以通过反射和反序列化破坏掉 由于枚举类型的特性，保证了线程安全、反射安全和反序列化安全 在《Effective Java》书中有一句话是： 单元素的枚举类型已经成为实现Singleton的最佳方法。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[浅谈AOP]]></title>
      <url>%2FSpring%2FSpring%2F%E6%B5%85%E8%B0%88AOP%2F</url>
      <content type="text"><![CDATA[AOP（Aspect-Oriented Programming，面向切面编程）是一种编程的思想。是对OOP的补充和完善。OOP擅长纵向的编程，对横向编程无力，因为会产生大量重复代码。而AOP的横向编程能力正好弥补了这一缺陷。 java实现AOP1. 过滤器也就是Filter，技术基于java的回调机制。设计的模式使用的责任链模式。 2. 拦截器技术基于java的反射。设计的模式使用的代理模式。 可以是动态代理，也可以是静态代理。 因为使用了代理模式，所以可以在拦截前做一些事，在拦截后再做一些事。 过滤器和拦截器的区别 过滤器基于回调，拦截器基于反射。 过滤器依赖servler容器，拦截器不依赖servler容器。 过滤器几乎可以对任何请求起作用，拦截器只能对action请求起作用。 拦截器可以访问action上下文、值栈里的对象，过滤器不能。 在action生命周期中，拦截器可以多次被调用，而过滤器只能在容器初始化时被调用一次。 看了这几点可能有疑惑，看下书上是怎么写的吧 执行顺序一个action请求进来。 过滤前–&gt;拦截前–&gt;action处理–&gt;拦截后–&gt;过滤后 Spring实现AOP1. aop不要被Spring的aop给迷惑了，aop是种编程思想，而Spring的aop只是这种思想的具体实现。使用的也是代理模式。可以选择通过JDKProxy或cglib来代理。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ResponseEntity和@ResponseBody的区别]]></title>
      <url>%2FSpring%2FSpring%2FResponseEntity%E5%92%8C%40ResponseBody%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
      <content type="text"><![CDATA[问题我在controller里定义了两个简单的handler来返回一个消息。12345@RequestMapping(value = "/message")@ResponseBodypublic Message get() &#123; return new Message(penguinCounter.incrementAndGet() + " penguin!");&#125; 我也可以用下面这种形式12345@RequestMapping(value = "/message")ResponseEntity&lt;Message&gt; get() &#123; Message message = new Message(penguinCounter.incrementAndGet() + " penguin!"); return new ResponseEntity&lt;Message&gt;(message, HttpStatus.OK);&#125; 那么这两种实现方式有什么区别呢？ 答案ResponseEntity可以更加灵活的在response里添加header信息。 通过Spring官方文档里的第四个构造函数1ResponseEntity(T body, MultiValueMap&lt;String,String&gt; headers, HttpStatus statusCode) 比较常用的headers有Status,Content-Type和Cache-Control。 如果不需要自己设置，使用@ResponseBody会稍微简便一点。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java的八种基本类型~byte]]></title>
      <url>%2FJava%E5%9F%BA%E7%A1%80%2Fjava%E5%9F%BA%E7%A1%80%2Fjava%E7%9A%84%E5%85%AB%E7%A7%8D%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B~byte%2F</url>
      <content type="text"><![CDATA[byte可表示的位数 byte与int互转 byte的包装类 byte与字节流（TODO） byte可表示的位数 12&gt; -2^7&gt; 12&gt; \downarrow&gt; 12&gt; 2^7-1&gt; byte在java中是一字节的，而一字节在内存中是8bit，而8bit中，第一位又是符号位，那只有7位可以表示数字，所以 byte能表示的最大的正数在内存中是0111 1111，即 127 byte能表示的最小的负数在内存中是1000 0000，即-128 可以用byte的包装类Byte.java的静态常量来查看12345678public class Test01 &#123; public static void main(String[] args) &#123; System.out.println(Byte.MIN_VALUE + &quot;~&quot; + Byte.MAX_VALUE); //输出：-128~127 byte b = 128; //error，编译报错 byte c = 127; //编译通过 byte d = (byte)128; //编译通过 &#125;&#125; byte与int互转 byte转int好像也没什么需要注意的… 123456789101112131415161718public class Test01 &#123; public static void main(String[] args) &#123; /** * int在byte范围内 */ byte b = 10; System.out.println(b + 10); //输出： 20 int b1 = b; System.out.println(b1); //输出： 10 /** * int不在byte范围内 */ byte c = 127; System.out.println(c + 10); //输出： 137 int d = c + 10; System.out.println(d); //输出： 137，与上一句是一样的，java底层是int计算的。 &#125;&#125; int转byte123456789101112131415161718public class Test01 &#123; public static void main(String[] args) &#123; int i = 128; byte j = (byte) i; //不强转编译报错 System.out.println(j); //输出： -128 int m = -129; byte n = (byte) m; //不强转编译报错 System.out.println(n); //输出： 127 int a = 127; byte b = (byte) a; //不强转编译报错 System.out.println(b); //输出： 127 byte e = 127; //这里字面量是int，为什么不用强转呢，jvm做了处理 System.out.println(e); //输出： 127 byte c = 127; byte d = 1; byte e = c + d; //error，编译报错，必须加上强转。因为java计算是通过int的。 &#125;&#125; [TODO:计算一下为什么128变成了-128] byte的包装类byte的包装类就是Byte，列举一下常见方法 12345678910111213- toString(byte b) //静态的，调用了Integer.toString()- ByteCache() //不是很懂，也不是静态方法啊- parseByte(String s) //超过范围或者不是数字会报：NumberFormatException，调用了Integer.parseInt()- valueOf() //把括号里的参数变成Byte对象，超过范围或者不是数字会报：NumberFormatException- byteValue() //返回Byte里的byte- shortValue() //返回short，代码里加了强转，平时不写是隐式类型转换，jvm实现的。- intValue(),longValue() //同上- floatValue(),doubleValue() //同上，但是不知道精度是否会丢失【TODO】- toString() //源码里调用了Integer.toString，非静态- hashCode() //返回这个类的hashCode- equals() //直接比byte了，也不用比hashCode了- compareTo(Byte anotherByte) //和另外一个Byte比较大小- compare(byte x, byte y) //静态方法 ByteCache可以查看128的hashCode共享 12345678910111213141516public class Test01 &#123; public static void main(String[] args) &#123; System.out.println(Byte.toString((byte) 1)); //1 System.out.println(Byte.parseByte(&quot;129&quot;)); //NumberFormatException：Value out of range. Value:&quot;129&quot; Radix:10 System.out.println(Byte.parseByte(&quot;x&quot;)); //NumberFormatException：For input string: &quot;x&quot; System.out.println(Byte.parseByte(&quot;20&quot;)); //20，调用了重写的toString方法 System.out.println(Byte.valueOf(&quot;20&quot;)); //20，与parseByte()的区别是返回类型不同，这个返回Byte System.out.println(Byte.valueOf((byte) 130)); //-126，与parseByte()的区别是返回类型不同，这个返回Byte Byte testByte = new Byte(&quot;-5&quot;); System.out.println(testByte.shortValue()); //-5 System.out.println(testByte.intValue()); //-5 System.out.println(testByte.longValue()); //-5 System.out.println(testByte.floatValue()); //-5.0 System.out.println(testByte.doubleValue()); //-5.0 &#125;&#125; Byte是final类型的类，也就是不可变的。（其他的基本类型的包装类也都是final类型的）下面的例子可以验证。1234567891011121314151617/** * 试验包装类的自增。 */public class Test001 &#123; private static void add(Byte b) &#123; b = b++; &#125; public static void main(String[] args) &#123; Byte a = 127; Byte b = 127; add(++a); System.out.println(a); //-128，自动拆箱 add(b); System.out.println(b); //127 &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Math类中的几种取整方式]]></title>
      <url>%2FJava%E5%9F%BA%E7%A1%80%2Fjava%E5%9F%BA%E7%A1%80%2FMath%E7%B1%BB%E4%B8%AD%E7%9A%84%E5%87%A0%E7%A7%8D%E5%8F%96%E6%95%B4%E6%96%B9%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[方法名 作用 ceil 天花板，即向上取整，结果大于等于原值 floor 地板，即向下取整，结果小于等于原值 round 四舍五入，算法为Math.floor(x+0.5) 代码示例12345678910111213141516171819202122public class test001 &#123; public static void main(String[] args) &#123; System.out.println(Math.floor(-10.4)); //-11.0 System.out.println(Math.floor(-10.6)); //-11.0 System.out.println(Math.floor(10.4)); //10.0 System.out.println(Math.floor(10.6)); //10.0 System.out.println(Math.ceil(-10.4)); //-10.0 System.out.println(Math.ceil(-10.6)); //-10.0 System.out.println(Math.ceil(10.4)); //11.0 System.out.println(Math.ceil(10.6)); //11.0 System.out.println(Math.round(-10.1)); //-10 System.out.println(Math.round(-10.5)); //-10 System.out.println(Math.round(-10.9)); //-11 System.out.println(Math.round(10.1)); //10 System.out.println(Math.round(10.5)); //11 System.out.println(Math.round(10.9)); //11 &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[switch的用法]]></title>
      <url>%2FJava%E5%9F%BA%E7%A1%80%2Fjava%E5%9F%BA%E7%A1%80%2Fswitch%E7%9A%84%E7%94%A8%E6%B3%95%2F</url>
      <content type="text"><![CDATA[前言switch-case语句完全可以与if-else语句互转，但通常来说，switch-case语句执行效率要高。 default在当前switch找不到匹配的case时执行。default并不是必须的。 一旦case匹配，就会顺序执行后面的程序代码，而不管后面的case是否匹配，直到遇见break。（所以这里有坑要避免） switch支持的类型java7的switch支持一下几种类型 类型 char Character byte Byte int Integer short Short String(java7) enum(java5) 代码实例default的使用default在当前switch找不到匹配的case时执行。default并不是必须的。default并不一定要写在最后，但是好怪。。1234567891011121314public class Test004 &#123; public static void main(String[] args) &#123; int i = 4; switch (i)&#123; case 1: //这个值要和括号里变量的类型一样，不然编译报错 System.out.print(1); break; default: System.out.print(0); case 5: System.out.print(5); &#125; &#125;&#125; 输出结果: 05因为default后面没有break，所以会执行case5。如前言里所说。 switch使用枚举123456789101112131415161718public class Test005 &#123; static enum E &#123; A, B, C, D &#125; public static void main(String[] args) &#123; E e = E.B; //注意不要写成Enum e = E.b; 否则case那句会编译报错 switch (e) &#123; case A: System.out.println(1); break; default: System.out.println(0); &#125; &#125;&#125; 忘记写break的陷阱123456789101112131415public class Test007 &#123; public static void main(String[] args) &#123; int i = 2; switch (i)&#123; case 1: System.out.print(1); case 2: System.out.print(2); case 3: System.out.print(3); default: System.out.print(0); &#125; &#125;&#125; 输出结果: 230]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java的八种基本类型的默认值]]></title>
      <url>%2FJava%E5%9F%BA%E7%A1%80%2Fjava%E5%9F%BA%E7%A1%80%2Fjava%E7%9A%84%E5%85%AB%E7%A7%8D%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E7%9A%84%E9%BB%98%E8%AE%A4%E5%80%BC%2F</url>
      <content type="text"><![CDATA[参见表格 基本类型 默认值 byte 0 short 0 int 0 long 0L float 0.0f double 0.0d char ‘\u0000’ boolean false 代码123456789101112131415161718192021222324252627/** * 实验基本类型的默认值 */public class Test002 &#123; private static byte defaultByte; //如果是final类型的话就必须初始化了，没有默认值 private static short defaultShort; private static int defaultInt; private static long defaultLong; private static float defaultFloat; private static double defaultDouble; private static char defaultChar; private static boolean defaultBoolean; private static String str; public static void main(String[] args) &#123; System.out.println(defaultByte); System.out.println(defaultShort); System.out.println(defaultInt); System.out.println(defaultLong); System.out.println(defaultFloat); System.out.println(defaultDouble); System.out.println(defaultChar); System.out.println(defaultBoolean); System.out.println("输出" + str); &#125;&#125; 输出00000.00.0 false输出null 注意点默认值只有成员变量才有，局部变量是没有默认值的。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[AngularJs验证动态生成的表单]]></title>
      <url>%2FJavaScript%2FJavaScript%2FAngularJs%E9%AA%8C%E8%AF%81%E5%8A%A8%E6%80%81%E7%94%9F%E6%88%90%E7%9A%84%E8%A1%A8%E5%8D%95%2F</url>
      <content type="text"><![CDATA[有这么一个需求，我的表单是ng-repeat生成的，但是要做表单验证。而AngularJs的表单验证是和name绑定的。如下。1234567&lt;p&gt;邮箱:&lt;br&gt; &lt;input type="email" name="email" ng-model="user.email" required&gt; &lt;span style="color:red" ng-show="myForm.email.$dirty &amp;&amp; myForm.email.$invalid"&gt; &lt;span ng-show="myForm.email.$error.required"&gt;邮箱是必须的。&lt;/span&gt; &lt;span ng-show="myForm.email.$error.email"&gt;非法的邮箱地址。&lt;/span&gt; &lt;/span&gt;&lt;/p&gt; 我把name改成{ {user.email} }，验证的地方改成myForm.{ {user.email} }.$error.required。报错。 解决方法google了一下，用ng-form标签123456789&lt;form name="outerForm"&gt;&lt;div ng-repeat="item in items"&gt; &lt;ng-form name="innerForm"&gt; &lt;input type="text" name="qwe" ng-model="item.foo" /&gt; &lt;span ng-show="innerForm.qwe.$error.required"&gt;required&lt;/span&gt; &lt;/ng-form&gt;&lt;/div&gt;&lt;input type="submit" ng-disabled="outerForm.$invalid" /&gt;&lt;/form&gt; 这里的name可以随便写了，只要和验证的地方对应就好了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java数组复制的四种方式]]></title>
      <url>%2FJava%E5%9F%BA%E7%A1%80%2Fjava%E5%9F%BA%E7%A1%80%2Fjava%E6%95%B0%E7%BB%84%E5%A4%8D%E5%88%B6%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[我测试出来的效率如图。 但是clone方法和Arrays.copyOf谁快不好说，貌似和数据量也有关系。 反正System.arrayCopy肯定是最快的，因为是native的方法。ArrayList里用的也是这个方法。 Arrays.copyOf底层用的其实也是System.arrayCopy 测试代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public class ArrayCopyTest &#123; private static String[] src = &#123;"Aaaaaaaaaa", "Vvvvvvv", "Bbbb", "Cccc", "Dddd", "Eddeee", "FFFFFFffffffff", "Aaaaaaaaaa", "Vvvvvvv", "Bbbb", "Cccc", "Dddd", "Eddeee", "FFFFFFffffffff", "Aaaaaaaaaa", "Vvvvvvv", "Bbbb", "Cccc", "Dddd", "Eddeee", "FFFFFFffffffff", "Aaaaaaaaaa", "Vvvvvvv", "Bbbb", "Cccc", "Dddd", "Eddeee", "FFFFFFffffffff", "Aaaaaaaaaa", "Vvvvvvv", "Bbbb", "Cccc", "Dddd", "Eddeee", "FFFFFFffffffff", "Aaaaaaaaaa", "Vvvvvvv", "Bbbb", "Cccc", "Dddd", "Eddeee", "FFFFFFffffffff", "Aaaaaaaaaa", "Vvvvvvv", "Bbbb", "Cccc", "Dddd", "Eddeee", "FFFFFFffffffff", "Aaaaaaaaaa", "Vvvvvvv", "Bbbb", "Cccc", "Dddd", "Eddeee", "FFFFFFffffffff", "Aaaaaaaaaa", "Vvvvvvv", "Bbbb", "Cccc", "Dddd", "Eddeee", "FFFFFFffffffff", "Aaaaaaaaaa", "Vvvvvvv", "Bbbb", "Cccc", "Dddd", "Eddeee", "FFFFFFffffffff"&#125;; private static String[] dst; public static void main(String[] args) &#123; int num = 5000000; System.out.println(forCopy(num)); System.out.println(cloneCopy(num)); System.out.println(systemJNICopy(num)); System.out.println(ArraysToolCopy(num)); &#125; private static long forCopy(int num) &#123; long start = System.currentTimeMillis(); while (num-- &gt; 0) &#123; int size = src.length; dst = new String[size]; for (int i = 0; i &lt; size; i++) &#123; dst[i] = src[i]; &#125; &#125; long end = System.currentTimeMillis(); return end - start; &#125; private static long cloneCopy(int num) &#123; long start = System.currentTimeMillis(); while (num-- &gt; 0) &#123; dst = src.clone(); &#125; long end = System.currentTimeMillis(); return end - start; &#125; private static long systemJNICopy(int num) &#123; long start = System.currentTimeMillis(); while (num-- &gt; 0) &#123; System.arraycopy(src, 0, dst, 0, src.length); &#125; long end = System.currentTimeMillis(); return end - start; &#125; private static long ArraysToolCopy(int num) &#123; long start = System.currentTimeMillis(); while (num-- &gt; 0) &#123; dst = Arrays.copyOf(src, src.length); &#125; long end = System.currentTimeMillis(); return end - start; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[final的用法]]></title>
      <url>%2FJava%E5%9F%BA%E7%A1%80%2Fjava%E5%9F%BA%E7%A1%80%2Ffinal%E7%9A%84%E7%94%A8%E6%B3%95%2F</url>
      <content type="text"><![CDATA[用final可以修饰类，方法，变量。分别表示类不可被继承，方法不可重写，变量不可变（不可变指的是引用地址不可变，内部的值还是可以变的）。 代码实例final修饰的成员变量被final修饰的类变量就变成了常量，必须要进行初始化，有两次机会可以初始化，一是声明的时候直接初始化，或者在构造函数里初始化。12345678910111213141516public class Test008 &#123; final int PI; //编译报错，未初始化 public Test008()&#123; &#125; public Test008(int i)&#123; PI = i; &#125; public static void main(String[] args) &#123; &#125;&#125; 这段代码是有编译报错的，因为new Test008()的时候，PI是没有被初始化的。所以要嘛在无参构造里也加上初始化，要嘛删掉这个无参构造。 final修饰的局部变量123456public class Test008 &#123; public static void main(String[] args) &#123; final int i; System.out.println(i); //编译报错，未初始化 &#125;&#125; 局部变量和成员变量不一样在，可以声明成final且不初始化，但是在使用的地方会编译报错。 final定义的基本类型的运算Java表达式转型规则由低到高转换： 所有的byte,short,char型的值将被提升为int型； 如果有一个操作数是long型，计算结果是long型； 如果有一个操作数是float型，计算结果是float型； 如果有一个操作数是double型，计算结果是double型； 被final修饰的两个常量运算会直接在编译期间获得值； 例一123456public class Test &#123; public static void main(String... args) &#123; byte b1 = 1, b2 = 2, b3; b3 = (byte) (b1 + b2); //需要强转，因为计算结果为int &#125;&#125; 反编译结果123456789101112public static void main(java.lang.String[]); Code: 0: iconst_1 //整数1入栈，操作数栈【1】 1: istore_1 //弹出栈顶元素，赋值给索引为1的变量，操作数栈【】 2: iconst_2 //整数1入栈，操作数栈【2】 3: istore_2 //弹出栈顶元素，赋值给索引为2的变量，操作数栈【】 4: iload_1 //索引为1的变量的值入栈，操作数栈【1】 5: iload_2 //索引为2的变量的值入栈，操作数栈【1|2】 6: iadd //栈顶的两个元素相加，操作数栈【3】 7: i2b //把int型转成byte型，操作数栈【3】 8: istore_3 //弹出栈顶元素，赋值给索引为3的变量，操作数栈【】 9: return 例二123456public class Test &#123; public static void main(String... args) &#123; final byte b1 = 1, b2 = 2; byte b3 = b1 + b2; //不需要强转，因为这就是byte b3 = 3; &#125;&#125; 反编译结果123456789public static void main(java.lang.String[]); Code: 0: iconst_1 //将一个int型常量值推送至栈顶，操作数栈【1】 1: istore_1 //弹出栈顶元素，赋值给索引为1的变量，操作数栈【】 2: iconst_2 //将一个int型常量值推送至栈顶，操作数栈【2】 3: istore_2 //弹出栈顶元素，赋值给索引为2的变量，操作数栈【】 4: iconst_3 //将一个int型常量值推送至栈顶，操作数栈【3】 5: istore_3 //弹出栈顶元素，赋值给索引为3的变量，操作数栈【】 6: return 例三123456public class Test &#123; public static void main(String... args) &#123; final byte b1 = 127, b2 = 3; byte b3 = (byte) (b1 + b2); //需要强转，因为这就是byte b3 = 130;这是不合法的 &#125;&#125; 反编译结果123456789public static void main(java.lang.String[]); Code: 0: bipush 127 //将一个byte型常量值推送至栈顶，操作数栈【127】 2: istore_1 //弹出栈顶元素，赋值给索引为1的变量，操作数栈【】 3: iconst_3 //将一个int型常量值推送至栈顶，操作数栈【3】 4: istore_2 //弹出栈顶元素，赋值给索引为2的变量，操作数栈【】 5: bipush -126 //将一个byte型常量值推送至栈顶，操作数栈【-126】 7: istore_3 //弹出栈顶元素，赋值给索引为3的变量，操作数栈【】 8: return 这里为什么是bipush呢？因为-1 ~ 5使用iconst_m1 ~ iconst_5来入栈的。 例四1234567public class Test0 &#123; public static void main(String[] args) &#123; final byte b1 = 2; byte b2 = 3; byte b3 = (byte) (b1 + b2); //需要强转 &#125;&#125; 123456789101112public static void main(java.lang.String[]); Code: 0: iconst_2 //将一个int型常量值推送至栈顶，操作数栈【2】 1: istore_1 //弹出栈顶元素，赋值给索引为1的变量，操作数栈【】 2: iconst_3 //将一个int型常量值推送至栈顶，操作数栈【3】 3: istore_2 //弹出栈顶元素，赋值给索引为2的变量，操作数栈【】 4: iconst_2 //将一个int型常量值推送至栈顶，操作数栈【2】 5: iload_2 //索引为1的变量的值入栈，操作数栈【2|3】 6: iadd //栈顶的两个元素相加，操作数栈【5】 7: i2b //把int型转成byte型，操作数栈【5】 8: istore_3 //弹出栈顶元素，赋值给索引为3的变量，操作数栈【】 9: return 可以发现，例二和例三少了一个iadd的过程，final直接在编译阶段就计算出来了。 从例四可以看出，一个final类型和非final类型的数相加，final类的数是从常量池里取了以后压入栈的，而非final类的数是从变量里load了以后压入栈的。 例五12345678public class Test &#123; public static void main(String[] args) &#123; int i = 10; double d = 7.0; float f = (float) (i % d); System.out.println(f); &#125;&#125; 反编译后1234567891011121314151617 public static void main(java.lang.String[]); Code: 0: bipush 10 2: istore_1 3: ldc2_w #2 // double 7.0d //将long或double型常量值从常量池中推送至栈顶（宽索引） 6: dstore_2 7: iload_1 8: i2d //栈顶int值强转double值，并且结果进栈 9: dload_2 10: drem //栈顶两double型数值作取模运算，并且结果进栈 11: d2f //栈顶double值强转float值，并且结果进栈 12: fstore 4 //这里的4指的是第四个变量，fstore_1指的是第二个变量。 14: getstatic #4 // Field java/lang/System.out:Ljava/io/PrintStream; 17: fload 4 19: invokevirtual #5 // Method java/io/PrintStream.println:(F)V 22: return&#125; 可以看到，运算的时候，把int转成了double的，符合了小转大的规则；]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[通过js实现导入导出txt格式]]></title>
      <url>%2FJavaScript%2FJavaScript%2F%E9%80%9A%E8%BF%87js%E5%AE%9E%E7%8E%B0%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BAtxt%E6%A0%BC%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[项目中有一个需求是要导出页面上的配置，然后又不想走后台来实现。google之~ 导出使用FileSaver.min.js FileSaver.min.js的github地址 示例（项目用的是AngularJs）:12345678910PatientVisitModel.prototype.downloadConfig = function () &#123; var saveText = &#123;&#125;; saveText.currentType = this.currentType; saveText.currentConfig = this.uiConfigs; var blob = new Blob([JSON.stringify(saveText)], &#123;type: "text/plain;charset=utf-8"&#125;); saveAs(blob, "hello world.txt");&#125;; 导入使用HTML5.JS的FileReader对象123456789101112131415PatientVisitModel.prototype.uploadConfig = function (myFile) &#123; var self = this; var file = myFile.files[0]; var reader = new FileReader(); //将文件以文本形式读入页面 reader.readAsText(file); reader.onload = function() &#123; var resultText = JSON.parse(this.result); self.uiConfigs = resultText.currentConfig; self.currentType = resultText.currentType; &#125;;&#125;; html页面上的写法1&lt;input type="file" id="file-input" onchange="angular.element(this).scope().patientVisitModel.uploadConfig(this)" &gt;]]></content>
    </entry>

    
  
  
</search>
