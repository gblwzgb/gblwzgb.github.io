<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Java设计模式--单例模式]]></title>
      <url>%2F2017%2F03%2F03%2FJava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F--%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[单例模式介绍使用单例可以减少不必要的系统开销，比如Spring里配置的数据源，创建和销毁耗费大量的资源，所以就用单例来保证项目加载的时候只生成一个实例，大家公用该实例。Spring的bean默认都是Singleton的。 单例模式有以下特点： 单例类只能有一个实例。 单例类必须自己创建自己的唯一实例。 单例类必须给所有其他对象提供这一实例。 单例模式的写法我画了张图来总结一下我所知道的单例模式的写法。 具体代码演示 懒汉式12345678910111213141516public class SingletonDemo01 &#123; private static SingletonDemo01 instance = null; private SingletonDemo01() &#123; &#125; public static SingletonDemo01 getInstance() &#123; if (instance == null) &#123; instance = new SingletonDemo01(); &#125; return instance; &#125;&#125; 这个有线程安全问题：线程A判断完实例没有创建，刚刚准备创建对象的时候，时间片切换到第二个线程B，这个时候线程B也发现实例没有创建，然后两个线程就各创建了一个对象了。 饿汉式12345678910111213public class SingletonDemo02 &#123; private static SingletonDemo02 instance = new SingletonDemo02(); private SingletonDemo02() &#123; //设置私有构造外部就不能通过new来新建实例了。 &#125; public static SingletonDemo02 getInstance() &#123; return instance; &#125;&#125; 优点： 饿汉模式简单，也没有线程安全问题。 了解过类加载机制的同学可能要问，如果线程A和线程B同时触发了类加载机制怎么办呢？会不会在线程切换间创建两个对象？没关系，在jvm里，类加载的时候会自动的加锁，并且有CAS保证了只有一个对象被创建。具体细节这里不展开。 缺点： 如果我的类里定义了其他静态方法或静态变量，我只是想用一下静态方法或变量，依据getstatic指令触发类的初始化，这个时候，instance变量会跟着一起初始化，也就创建了一个SingletonDemo02的对象，白白浪费了内存。 单检锁12345678910111213141516public class SingletonDemo03 &#123; private static SingletonDemo03 instance = null; private SingletonDemo03() &#123; &#125; public synchronized static SingletonDemo03 getInstance() &#123; if (instance == null) &#123; instance = new SingletonDemo03(); &#125; return instance; &#125;&#125; 优点: 线程安全。 在懒汉式上加上了synchronized关键字，也就解决了普通懒汉式线程不安全的问题。 缺点： 锁的粒度太粗，instance==null的判断并不需要加锁。 双检锁1234567891011121314151617181920public class SingletonDemo04 &#123; private static volatile SingletonDemo04 instance = null; private SingletonDemo04() &#123; &#125; public synchronized static SingletonDemo04 getInstance() &#123; if (instance == null) &#123; synchronized (SingletonDemo04.class) &#123; if (instance == null) &#123; instance = new SingletonDemo04(); &#125; &#125; &#125; return instance; &#125;&#125; jvm创建对象的时候大致干三件事： 在堆上分配内存空间 执行类的构造方法初始化参数 把创建的对象指向分配的内存空间地址 在编译优化里，这几步的执行顺序并不是一定的，可能是123，也可能是132。 这里的volatile是为了防止132运行的时候，别的线程发现对象不为null，然后直接去操作对象里的某些参数。 优点: 线程安全，锁的粒度小 缺点： 多线程学的不扎实的可能很难理解。 静态内部类123456789101112131415public class SingletonDemo05 &#123; private SingletonDemo05() &#123; &#125; private static final class SingletonManager &#123; private static SingletonDemo05 instance = new SingletonDemo05(); &#125; public static SingletonDemo05 getInstance() &#123; return SingletonManager.instance; &#125;&#125; 优点: 改进了饿汉式的缺点，可以发现，现在即使SingletonDemo05里有其他的静态方法，只要我不调用getInstance()方法，我就不会白白的创建一个对象了。 枚举123456789101112131415161718public enum SingletonDemo06 &#123; INSTANCE; private Resource instance; SingletonDemo06() &#123; instance = new Resource(); &#125; public Resource getInstance() &#123; return instance; &#125;&#125;class Resource &#123;&#125; 优点： 前面的几种方式都可以通过反射和反序列化破坏掉 由于枚举类型的特性，保证了线程安全、反射安全和反序列化安全 在《Effective Java》书中有一句话是： 单元素的枚举类型已经成为实现Singleton的最佳方法。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[浅谈AOP]]></title>
      <url>%2F2017%2F03%2F03%2F%E6%B5%85%E8%B0%88AOP%2F</url>
      <content type="text"><![CDATA[AOP（Aspect-Oriented Programming，面向切面编程）是一种编程的思想。是对OOP的补充和完善。OOP擅长纵向的编程，对横向编程无力，因为会产生大量重复代码。而AOP的横向编程能力正好弥补了这一缺陷。 java实现AOP1. 过滤器也就是Filter，技术基于java的回调机制。设计的模式使用的责任链模式。 2. 拦截器技术基于java的反射。设计的模式使用的代理模式。 可以是动态代理，也可以是静态代理。 因为使用了代理模式，所以可以在拦截前做一些事，在拦截后再做一些事。 过滤器和拦截器的区别 过滤器基于回调，拦截器基于反射。 过滤器依赖servler容器，拦截器不依赖servler容器。 过滤器几乎可以对任何请求起作用，拦截器只能对action请求起作用。 拦截器可以访问action上下文、值栈里的对象，过滤器不能。 在action生命周期中，拦截器可以多次被调用，而过滤器只能在容器初始化时被调用一次。 看了这几点可能有疑惑，看下书上是怎么写的吧 执行顺序一个action请求进来。 过滤前–&gt;拦截前–&gt;action处理–&gt;拦截后–&gt;过滤后 Spring实现AOP1. aop不要被Spring的aop给迷惑了，aop是种编程思想，而Spring的aop只是这种思想的具体实现。使用的也是代理模式。可以选择通过JDKProxy或cglib来代理。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[AngularJs验证动态生成的表单]]></title>
      <url>%2F2017%2F02%2F28%2FAngularJs%E9%AA%8C%E8%AF%81%E5%8A%A8%E6%80%81%E7%94%9F%E6%88%90%E7%9A%84%E8%A1%A8%E5%8D%95%2F</url>
      <content type="text"><![CDATA[有这么一个需求，我的表单是ng-repeat生成的，但是要做表单验证。而AngularJs的表单验证是和name绑定的。如下。1234567&lt;p&gt;邮箱:&lt;br&gt; &lt;input type="email" name="email" ng-model="user.email" required&gt; &lt;span style="color:red" ng-show="myForm.email.$dirty &amp;&amp; myForm.email.$invalid"&gt; &lt;span ng-show="myForm.email.$error.required"&gt;邮箱是必须的。&lt;/span&gt; &lt;span ng-show="myForm.email.$error.email"&gt;非法的邮箱地址。&lt;/span&gt; &lt;/span&gt;&lt;/p&gt; 我把name改成{ {user.email} }，验证的地方改成myForm.{ {user.email} }.$error.required。报错。 解决方法google了一下，用ng-form标签123456789&lt;form name="outerForm"&gt;&lt;div ng-repeat="item in items"&gt; &lt;ng-form name="innerForm"&gt; &lt;input type="text" name="qwe" ng-model="item.foo" /&gt; &lt;span ng-show="innerForm.qwe.$error.required"&gt;required&lt;/span&gt; &lt;/ng-form&gt;&lt;/div&gt;&lt;input type="submit" ng-disabled="outerForm.$invalid" /&gt;&lt;/form&gt; 这里的name可以随便写了，只要和验证的地方对应就好了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Math类中的几种取整方式]]></title>
      <url>%2F2017%2F02%2F28%2FMath%E7%B1%BB%E4%B8%AD%E7%9A%84%E5%87%A0%E7%A7%8D%E5%8F%96%E6%95%B4%E6%96%B9%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[方法名 作用 ceil 天花板，即向上取整，结果大于等于原值 floor 地板，即向下取整，结果小于等于原值 round 四舍五入，算法为Math.floor(x+0.5) 代码示例12345678910111213141516171819202122public class test001 &#123; public static void main(String[] args) &#123; System.out.println(Math.floor(-10.4)); //-11.0 System.out.println(Math.floor(-10.6)); //-11.0 System.out.println(Math.floor(10.4)); //10.0 System.out.println(Math.floor(10.6)); //10.0 System.out.println(Math.ceil(-10.4)); //-10.0 System.out.println(Math.ceil(-10.6)); //-10.0 System.out.println(Math.ceil(10.4)); //11.0 System.out.println(Math.ceil(10.6)); //11.0 System.out.println(Math.round(-10.1)); //-10 System.out.println(Math.round(-10.5)); //-10 System.out.println(Math.round(-10.9)); //-11 System.out.println(Math.round(10.1)); //10 System.out.println(Math.round(10.5)); //11 System.out.println(Math.round(10.9)); //11 &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java数组复制的四种方式]]></title>
      <url>%2F2017%2F02%2F28%2Fjava%E6%95%B0%E7%BB%84%E5%A4%8D%E5%88%B6%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[我测试出来的效率如图。 但是clone方法和Arrays.copyOf谁快不好说，貌似和数据量也有关系。 反正System.arrayCopy肯定是最快的，因为是native的方法。ArrayList里用的也是这个方法。 Arrays.copyOf底层用的其实也是System.arrayCopy 测试代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public class ArrayCopyTest &#123; private static String[] src = &#123;"Aaaaaaaaaa", "Vvvvvvv", "Bbbb", "Cccc", "Dddd", "Eddeee", "FFFFFFffffffff", "Aaaaaaaaaa", "Vvvvvvv", "Bbbb", "Cccc", "Dddd", "Eddeee", "FFFFFFffffffff", "Aaaaaaaaaa", "Vvvvvvv", "Bbbb", "Cccc", "Dddd", "Eddeee", "FFFFFFffffffff", "Aaaaaaaaaa", "Vvvvvvv", "Bbbb", "Cccc", "Dddd", "Eddeee", "FFFFFFffffffff", "Aaaaaaaaaa", "Vvvvvvv", "Bbbb", "Cccc", "Dddd", "Eddeee", "FFFFFFffffffff", "Aaaaaaaaaa", "Vvvvvvv", "Bbbb", "Cccc", "Dddd", "Eddeee", "FFFFFFffffffff", "Aaaaaaaaaa", "Vvvvvvv", "Bbbb", "Cccc", "Dddd", "Eddeee", "FFFFFFffffffff", "Aaaaaaaaaa", "Vvvvvvv", "Bbbb", "Cccc", "Dddd", "Eddeee", "FFFFFFffffffff", "Aaaaaaaaaa", "Vvvvvvv", "Bbbb", "Cccc", "Dddd", "Eddeee", "FFFFFFffffffff", "Aaaaaaaaaa", "Vvvvvvv", "Bbbb", "Cccc", "Dddd", "Eddeee", "FFFFFFffffffff"&#125;; private static String[] dst; public static void main(String[] args) &#123; int num = 5000000; System.out.println(forCopy(num)); System.out.println(cloneCopy(num)); System.out.println(systemJNICopy(num)); System.out.println(ArraysToolCopy(num)); &#125; private static long forCopy(int num) &#123; long start = System.currentTimeMillis(); while (num-- &gt; 0) &#123; int size = src.length; dst = new String[size]; for (int i = 0; i &lt; size; i++) &#123; dst[i] = src[i]; &#125; &#125; long end = System.currentTimeMillis(); return end - start; &#125; private static long cloneCopy(int num) &#123; long start = System.currentTimeMillis(); while (num-- &gt; 0) &#123; dst = src.clone(); &#125; long end = System.currentTimeMillis(); return end - start; &#125; private static long systemJNICopy(int num) &#123; long start = System.currentTimeMillis(); while (num-- &gt; 0) &#123; System.arraycopy(src, 0, dst, 0, src.length); &#125; long end = System.currentTimeMillis(); return end - start; &#125; private static long ArraysToolCopy(int num) &#123; long start = System.currentTimeMillis(); while (num-- &gt; 0) &#123; dst = Arrays.copyOf(src, src.length); &#125; long end = System.currentTimeMillis(); return end - start; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[final的用法]]></title>
      <url>%2F2017%2F02%2F28%2Ffinal%E7%9A%84%E7%94%A8%E6%B3%95%2F</url>
      <content type="text"><![CDATA[用final可以修饰类，方法，变量。分别表示类不可被继承，方法不可重写，变量不可变（不可变指的是引用地址不可变，内部的值还是可以变的）。 代码实例final修饰的成员变量被final修饰的类变量就变成了常量，必须要进行初始化，有两次机会可以初始化，一是声明的时候直接初始化，或者在构造函数里初始化。12345678910111213141516public class Test008 &#123; final int PI; //编译报错，未初始化 public Test008()&#123; &#125; public Test008(int i)&#123; PI = i; &#125; public static void main(String[] args) &#123; &#125;&#125; 这段代码是有编译报错的，因为new Test008()的时候，PI是没有被初始化的。所以要嘛在无参构造里也加上初始化，要嘛删掉这个无参构造。 final修饰的局部变量123456public class Test008 &#123; public static void main(String[] args) &#123; final int i; System.out.println(i); //编译报错，未初始化 &#125;&#125; 局部变量和成员变量不一样在，可以声明成final且不初始化，但是在使用的地方会编译报错。 final定义的基本类型的运算Java表达式转型规则由低到高转换： 所有的byte,short,char型的值将被提升为int型； 如果有一个操作数是long型，计算结果是long型； 如果有一个操作数是float型，计算结果是float型； 如果有一个操作数是double型，计算结果是double型； 被final修饰的两个常量运算会直接在编译期间获得值； 例一123456public class Test &#123; public static void main(String... args) &#123; byte b1 = 1, b2 = 2, b3; b3 = (byte) (b1 + b2); //需要强转，因为计算结果为int &#125;&#125; 反编译结果123456789101112public static void main(java.lang.String[]); Code: 0: iconst_1 //整数1入栈，操作数栈【1】 1: istore_1 //弹出栈顶元素，赋值给索引为1的变量，操作数栈【】 2: iconst_2 //整数1入栈，操作数栈【2】 3: istore_2 //弹出栈顶元素，赋值给索引为2的变量，操作数栈【】 4: iload_1 //索引为1的变量的值入栈，操作数栈【1】 5: iload_2 //索引为2的变量的值入栈，操作数栈【1|2】 6: iadd //栈顶的两个元素相加，操作数栈【3】 7: i2b //把int型转成byte型，操作数栈【3】 8: istore_3 //弹出栈顶元素，赋值给索引为3的变量，操作数栈【】 9: return 例二123456public class Test &#123; public static void main(String... args) &#123; final byte b1 = 1, b2 = 2; byte b3 = b1 + b2; //不需要强转，因为这就是byte b3 = 3; &#125;&#125; 反编译结果123456789public static void main(java.lang.String[]); Code: 0: iconst_1 //将一个int型常量值推送至栈顶，操作数栈【1】 1: istore_1 //弹出栈顶元素，赋值给索引为1的变量，操作数栈【】 2: iconst_2 //将一个int型常量值推送至栈顶，操作数栈【2】 3: istore_2 //弹出栈顶元素，赋值给索引为2的变量，操作数栈【】 4: iconst_3 //将一个int型常量值推送至栈顶，操作数栈【3】 5: istore_3 //弹出栈顶元素，赋值给索引为3的变量，操作数栈【】 6: return 例三123456public class Test &#123; public static void main(String... args) &#123; final byte b1 = 127, b2 = 3; byte b3 = (byte) (b1 + b2); //需要强转，因为这就是byte b3 = 130;这是不合法的 &#125;&#125; 反编译结果123456789public static void main(java.lang.String[]); Code: 0: bipush 127 //将一个byte型常量值推送至栈顶，操作数栈【127】 2: istore_1 //弹出栈顶元素，赋值给索引为1的变量，操作数栈【】 3: iconst_3 //将一个int型常量值推送至栈顶，操作数栈【3】 4: istore_2 //弹出栈顶元素，赋值给索引为2的变量，操作数栈【】 5: bipush -126 //将一个byte型常量值推送至栈顶，操作数栈【-126】 7: istore_3 //弹出栈顶元素，赋值给索引为3的变量，操作数栈【】 8: return 这里为什么是bipush呢？因为-1 ~ 5使用iconst_m1 ~ iconst_5来入栈的。 例四1234567public class Test0 &#123; public static void main(String[] args) &#123; final byte b1 = 2; byte b2 = 3; byte b3 = (byte) (b1 + b2); //需要强转 &#125;&#125; 123456789101112public static void main(java.lang.String[]); Code: 0: iconst_2 //将一个int型常量值推送至栈顶，操作数栈【2】 1: istore_1 //弹出栈顶元素，赋值给索引为1的变量，操作数栈【】 2: iconst_3 //将一个int型常量值推送至栈顶，操作数栈【3】 3: istore_2 //弹出栈顶元素，赋值给索引为2的变量，操作数栈【】 4: iconst_2 //将一个int型常量值推送至栈顶，操作数栈【2】 5: iload_2 //索引为1的变量的值入栈，操作数栈【2|3】 6: iadd //栈顶的两个元素相加，操作数栈【5】 7: i2b //把int型转成byte型，操作数栈【5】 8: istore_3 //弹出栈顶元素，赋值给索引为3的变量，操作数栈【】 9: return 可以发现，例二和例三少了一个iadd的过程，final直接在编译阶段就计算出来了。 从例四可以看出，一个final类型和非final类型的数相加，final类的数是从常量池里取了以后压入栈的，而非final类的数是从变量里load了以后压入栈的。 例五12345678public class Test &#123; public static void main(String[] args) &#123; int i = 10; double d = 7.0; float f = (float) (i % d); System.out.println(f); &#125;&#125; 反编译后1234567891011121314151617 public static void main(java.lang.String[]); Code: 0: bipush 10 2: istore_1 3: ldc2_w #2 // double 7.0d //将long或double型常量值从常量池中推送至栈顶（宽索引） 6: dstore_2 7: iload_1 8: i2d //栈顶int值强转double值，并且结果进栈 9: dload_2 10: drem //栈顶两double型数值作取模运算，并且结果进栈 11: d2f //栈顶double值强转float值，并且结果进栈 12: fstore 4 //这里的4指的是第四个变量，fstore_1指的是第二个变量。 14: getstatic #4 // Field java/lang/System.out:Ljava/io/PrintStream; 17: fload 4 19: invokevirtual #5 // Method java/io/PrintStream.println:(F)V 22: return&#125; 可以看到，运算的时候，把int转成了double的，符合了小转大的规则；]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java的八种基本类型~byte]]></title>
      <url>%2F2017%2F02%2F28%2Fjava%E7%9A%84%E5%85%AB%E7%A7%8D%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B~byte%2F</url>
      <content type="text"><![CDATA[byte可表示的位数 byte与int互转 byte的包装类 byte与字节流（TODO） byte可表示的位数 12&gt; -2^7&gt; 12&gt; \downarrow&gt; 12&gt; 2^7-1&gt; byte在java中是一字节的，而一字节在内存中是8bit，而8bit中，第一位又是符号位，那只有7位可以表示数字，所以 byte能表示的最大的正数在内存中是0111 1111，即 127 byte能表示的最小的负数在内存中是1000 0000，即-128 可以用byte的包装类Byte.java的静态常量来查看12345678public class Test01 &#123; public static void main(String[] args) &#123; System.out.println(Byte.MIN_VALUE + &quot;~&quot; + Byte.MAX_VALUE); //输出：-128~127 byte b = 128; //error，编译报错 byte c = 127; //编译通过 byte d = (byte)128; //编译通过 &#125;&#125; byte与int互转 byte转int好像也没什么需要注意的… 123456789101112131415161718public class Test01 &#123; public static void main(String[] args) &#123; /** * int在byte范围内 */ byte b = 10; System.out.println(b + 10); //输出： 20 int b1 = b; System.out.println(b1); //输出： 10 /** * int不在byte范围内 */ byte c = 127; System.out.println(c + 10); //输出： 137 int d = c + 10; System.out.println(d); //输出： 137，与上一句是一样的，java底层是int计算的。 &#125;&#125; int转byte123456789101112131415161718public class Test01 &#123; public static void main(String[] args) &#123; int i = 128; byte j = (byte) i; //不强转编译报错 System.out.println(j); //输出： -128 int m = -129; byte n = (byte) m; //不强转编译报错 System.out.println(n); //输出： 127 int a = 127; byte b = (byte) a; //不强转编译报错 System.out.println(b); //输出： 127 byte e = 127; //这里字面量是int，为什么不用强转呢，jvm做了处理 System.out.println(e); //输出： 127 byte c = 127; byte d = 1; byte e = c + d; //error，编译报错，必须加上强转。因为java计算是通过int的。 &#125;&#125; [TODO:计算一下为什么128变成了-128] byte的包装类byte的包装类就是Byte，列举一下常见方法 12345678910111213- toString(byte b) //静态的，调用了Integer.toString()- ByteCache() //不是很懂，也不是静态方法啊- parseByte(String s) //超过范围或者不是数字会报：NumberFormatException，调用了Integer.parseInt()- valueOf() //把括号里的参数变成Byte对象，超过范围或者不是数字会报：NumberFormatException- byteValue() //返回Byte里的byte- shortValue() //返回short，代码里加了强转，平时不写是隐式类型转换，jvm实现的。- intValue(),longValue() //同上- floatValue(),doubleValue() //同上，但是不知道精度是否会丢失【TODO】- toString() //源码里调用了Integer.toString，非静态- hashCode() //返回这个类的hashCode- equals() //直接比byte了，也不用比hashCode了- compareTo(Byte anotherByte) //和另外一个Byte比较大小- compare(byte x, byte y) //静态方法 ByteCache可以查看128的hashCode共享 12345678910111213141516public class Test01 &#123; public static void main(String[] args) &#123; System.out.println(Byte.toString((byte) 1)); //1 System.out.println(Byte.parseByte(&quot;129&quot;)); //NumberFormatException：Value out of range. Value:&quot;129&quot; Radix:10 System.out.println(Byte.parseByte(&quot;x&quot;)); //NumberFormatException：For input string: &quot;x&quot; System.out.println(Byte.parseByte(&quot;20&quot;)); //20，调用了重写的toString方法 System.out.println(Byte.valueOf(&quot;20&quot;)); //20，与parseByte()的区别是返回类型不同，这个返回Byte System.out.println(Byte.valueOf((byte) 130)); //-126，与parseByte()的区别是返回类型不同，这个返回Byte Byte testByte = new Byte(&quot;-5&quot;); System.out.println(testByte.shortValue()); //-5 System.out.println(testByte.intValue()); //-5 System.out.println(testByte.longValue()); //-5 System.out.println(testByte.floatValue()); //-5.0 System.out.println(testByte.doubleValue()); //-5.0 &#125;&#125; Byte是final类型的类，也就是不可变的。（其他的基本类型的包装类也都是final类型的）下面的例子可以验证。1234567891011121314151617/** * 试验包装类的自增。 */public class Test001 &#123; private static void add(Byte b) &#123; b = b++; &#125; public static void main(String[] args) &#123; Byte a = 127; Byte b = 127; add(++a); System.out.println(a); //-128，自动拆箱 add(b); System.out.println(b); //127 &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java的八种基本类型的默认值]]></title>
      <url>%2F2017%2F02%2F28%2Fjava%E7%9A%84%E5%85%AB%E7%A7%8D%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E7%9A%84%E9%BB%98%E8%AE%A4%E5%80%BC%2F</url>
      <content type="text"><![CDATA[参见表格 基本类型 默认值 byte 0 short 0 int 0 long 0L float 0.0f double 0.0d char ‘\u0000’ boolean false 代码123456789101112131415161718192021222324252627/** * 实验基本类型的默认值 */public class Test002 &#123; private static byte defaultByte; //如果是final类型的话就必须初始化了，没有默认值 private static short defaultShort; private static int defaultInt; private static long defaultLong; private static float defaultFloat; private static double defaultDouble; private static char defaultChar; private static boolean defaultBoolean; private static String str; public static void main(String[] args) &#123; System.out.println(defaultByte); System.out.println(defaultShort); System.out.println(defaultInt); System.out.println(defaultLong); System.out.println(defaultFloat); System.out.println(defaultDouble); System.out.println(defaultChar); System.out.println(defaultBoolean); System.out.println("输出" + str); &#125;&#125; 输出00000.00.0 false输出null 注意点默认值只有成员变量才有，局部变量是没有默认值的。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[switch的用法]]></title>
      <url>%2F2017%2F02%2F28%2Fswitch%E7%9A%84%E7%94%A8%E6%B3%95%2F</url>
      <content type="text"><![CDATA[前言switch-case语句完全可以与if-else语句互转，但通常来说，switch-case语句执行效率要高。 default在当前switch找不到匹配的case时执行。default并不是必须的。 一旦case匹配，就会顺序执行后面的程序代码，而不管后面的case是否匹配，直到遇见break。（所以这里有坑要避免） switch支持的类型java7的switch支持一下几种类型 类型 char Character byte Byte int Integer short Short String(java7) enum(java5) 代码实例default的使用default在当前switch找不到匹配的case时执行。default并不是必须的。default并不一定要写在最后，但是好怪。。1234567891011121314public class Test004 &#123; public static void main(String[] args) &#123; int i = 4; switch (i)&#123; case 1: //这个值要和括号里变量的类型一样，不然编译报错 System.out.print(1); break; default: System.out.print(0); case 5: System.out.print(5); &#125; &#125;&#125; 输出结果: 05因为default后面没有break，所以会执行case5。如前言里所说。 switch使用枚举123456789101112131415161718public class Test005 &#123; static enum E &#123; A, B, C, D &#125; public static void main(String[] args) &#123; E e = E.B; //注意不要写成Enum e = E.b; 否则case那句会编译报错 switch (e) &#123; case A: System.out.println(1); break; default: System.out.println(0); &#125; &#125;&#125; 忘记写break的陷阱123456789101112131415public class Test007 &#123; public static void main(String[] args) &#123; int i = 2; switch (i)&#123; case 1: System.out.print(1); case 2: System.out.print(2); case 3: System.out.print(3); default: System.out.print(0); &#125; &#125;&#125; 输出结果: 230]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[通过js实现导入导出txt格式]]></title>
      <url>%2F2017%2F02%2F28%2F%E9%80%9A%E8%BF%87js%E5%AE%9E%E7%8E%B0%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BAtxt%E6%A0%BC%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[项目中有一个需求是要导出页面上的配置，然后又不想走后台来实现。google之~ 导出使用FileSaver.min.js FileSaver.min.js的github地址 示例（项目用的是AngularJs）:12345678910PatientVisitModel.prototype.downloadConfig = function () &#123; var saveText = &#123;&#125;; saveText.currentType = this.currentType; saveText.currentConfig = this.uiConfigs; var blob = new Blob([JSON.stringify(saveText)], &#123;type: "text/plain;charset=utf-8"&#125;); saveAs(blob, "hello world.txt");&#125;; 导入使用HTML5.JS的FileReader对象123456789101112131415PatientVisitModel.prototype.uploadConfig = function (myFile) &#123; var self = this; var file = myFile.files[0]; var reader = new FileReader(); //将文件以文本形式读入页面 reader.readAsText(file); reader.onload = function() &#123; var resultText = JSON.parse(this.result); self.uiConfigs = resultText.currentConfig; self.currentType = resultText.currentType; &#125;;&#125;; html页面上的写法1&lt;input type="file" id="file-input" onchange="angular.element(this).scope().patientVisitModel.uploadConfig(this)" &gt;]]></content>
    </entry>

    
  
  
</search>
