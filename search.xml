<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[git如何忽略不想提交的文件]]></title>
      <url>%2Fgit%2Fgit%2Fgit%E5%A6%82%E4%BD%95%E5%BF%BD%E7%95%A5%E4%B8%8D%E6%83%B3%E6%8F%90%E4%BA%A4%E7%9A%84%E6%96%87%E4%BB%B6%2F</url>
      <content type="text"><![CDATA[1. 在根目录下新建一个文件.gitignore这里应该会提示请键入文件名，可找人要一份。或按以下操作解决 1. 在项目根目录下面创建`gitignore.txt`文件 2. 把你需要排除的文件名保存到`gitignore.txt`文件 3. 在项目根目录下面按住Shift键并右键然后选择`在此处打开命令窗口` 4. 执行命令`ren gitignore.txt .gitignore` 2. 拷入以下内容123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238################### Eclipse#################*.pydevproject.project.metadatabin/tmp/*.tmp*.bak*.swp*~.niblocal.properties.classpath.settings/.loadpath# External tool builders.externalToolBuilders/# Locally stored &quot;Eclipse launch configurations&quot;*.launch# CDT-specific.cproject# PDT-specific.buildpath################### Visual Studio################### Ignore Visual Studio temporary files, build results, and## files generated by popular Visual Studio add-ons.# User-specific files*.suo*.user*.sln.docstates# Build results[Dd]ebug/[Rr]elease/x64/build/[Bb]in/[Oo]bj/# MSTest test Results[Tt]est[Rr]esult*/[Bb]uild[Ll]og.**_i.c*_p.c*.ilk*.meta*.obj*.pch*.pdb*.pgc*.pgd*.rsp*.sbr*.tlb*.tli*.tlh*.tmp*.tmp_proj*.log*.vspscc*.vssscc.builds*.pidb*.log*.scc# Visual C++ cache filesipch/*.aps*.ncb*.opensdf*.sdf*.cachefile# Visual Studio profiler*.psess*.vsp*.vspx# Guidance Automation Toolkit*.gpState# ReSharper is a .NET coding add-in_ReSharper*/*.[Rr]e[Ss]harper# TeamCity is a build add-in_TeamCity*# DotCover is a Code Coverage Tool*.dotCover# NCrunch*.ncrunch*.*crunch*.local.xml# Installshield output folder[Ee]xpress/# DocProject is a documentation generator add-inDocProject/buildhelp/DocProject/Help/*.HxTDocProject/Help/*.HxCDocProject/Help/*.hhcDocProject/Help/*.hhkDocProject/Help/*.hhpDocProject/Help/Html2DocProject/Help/html# Click-Once directorypublish/# Publish Web Output*.Publish.xml*.pubxml*.publishproj# NuGet Packages Directory## TODO: If you have NuGet Package Restore enabled, uncomment the next line#packages/# Windows Azure Build Outputcsx*.build.csdef# Windows Store app package directoryAppPackages/# Otherssql/*.CacheClientBin/[Ss]tyle[Cc]op.*~$**~*.dbmdl*.[Pp]ublish.xml*.pfx*.publishsettings# RIA/Silverlight projectsGenerated_Code/# Backup &amp; report files from converting an old project file to a newer# Visual Studio version. Backup files are not needed, because we have git ;-)_UpgradeReport_Files/Backup*/UpgradeLog*.XMLUpgradeLog*.htm# SQL Server filesApp_Data/*.mdfApp_Data/*.ldf############### Windows detritus############## Windows image file cachesThumbs.dbehthumbs.db# Folder config fileDesktop.ini# Recycle Bin used on file shares$RECYCLE.BIN/# Mac crap.DS_Store############### Python#############*.py[cod]# Packages*.egg*.egg-infodist/build/eggs/parts/var/sdist/develop-eggs/.installed.cfg# Installer logspip-log.txt# Unit test / coverage reports.coverage.tox#Translations*.mo#Mr Developer.mr.developer.cfg################### idea#################*.iml.idea/################### maven#################target/*.war################### dev#################web/pt_zsyy-model/.checkstyledev/web/pt_zsyy/.springWebflowweb_sql/database.properties 3. 提交.gitignore题外话 使用.gitkeepGit会忽略空的文件夹。如果你想版本控制包括空文件夹，根据惯例会在空文件夹下放置.gitkeep文件。其实对文件名没有特定的要求。一旦一个空文件夹下有文件后，这个文件夹就会在版本控制范围内。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Spring配置欢迎页引发的思考]]></title>
      <url>%2FSpring%2FSpring%2FSpring%E9%85%8D%E7%BD%AE%E6%AC%A2%E8%BF%8E%E9%A1%B5%E5%BC%95%E5%8F%91%E7%9A%84%E6%80%9D%E8%80%83%2F</url>
      <content type="text"><![CDATA[引言今天下载了一个demo项目，跑起来可以默认打开index.jsp的欢迎页。但是把index.jsp换成index.html就会404。平时也没配置过欢迎页，就顺手研究了一下。于是就查漏补缺了以下知识点。 项目概述 项目中的web.xml 123456789&lt;servlet&gt; &lt;servlet-name&gt;mvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;mvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 项目的web.xml里没有配置&lt;welcome-file-list&gt; 知识点viewResolver开始我以为是这个bean的问题，因为我看到这个bean的配置里有个.jsp，后来才知道这个bean是在请求处理完以后，返回ModelAndView，把数据渲染到页面里用的。 三种index.html可行的方法 使用标签&lt;mvc:default-servlet-handler/&gt; 在xxxx-servlet.xml里定义这个标签。这个标签的作用是，当返回404的时候，就使用默认的servlet去处理这个请求。所以当使用index.html的时候，先经过DispatcherServlet，发现没有对用的handler，于是返回404，然后被默认的servlet处理，成功显示index.html的内容。 使用这个标签的时候，务必加上&lt;context:annotation-config /&gt;，不然就会发现普通的请求过不了了。原因可以参考这里 使用标签&lt;mvc:resource mapping=&quot;xx&quot; location=&quot;&quot;/&gt; 在xxxx-servlet.xml里定义这个标签。这个标签的作用是，当访问的是静态资源的时候，并且被mapping匹配到的话，都会把位置定位到相对路径location下。 定义一个使用default的servlet-mapping 1234&lt;servlet-mapping&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;url-pattern&gt;*.html&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 在项目的web.xml里加上这段代码也可以实现。因为index.html直接就匹配了default的servlet了。 /和/*的区别如果我把DispatcherServlet的匹配路径从/改成/*，就会发现连index.jsp也404了。这是为什么呢？ /*会匹配所有请求，如果请求没被其他servlet匹配走，那就都会走这个servlet，这种写法不是很推荐。还有个比较神奇的问题就是，当写成/*的时候，就不会去默认访问&lt;welcome-file-list&gt;里的欢迎页了。只有在访问的时候手动输入欢迎页的请求地址才能打开。 /呢，就是一个请求进来以后，所有的servlet都不匹配。就会通过/的servlet来实现。这种写法也不是很推荐的。 这里就要说到&lt;url-pattern&gt;的匹配优先级问题了。 &lt;url-pattern&gt;的匹配优先级精确路径&gt;最长路径&gt;扩展名 精确路径：类似&lt;url-pattern&gt;/demo.html&lt;/url-pattern&gt; 路径匹配：类似&lt;url-pattern&gt;/xxx/xx/x/*&lt;/url-pattern&gt; 扩展名匹配：类似&lt;url-pattern&gt;*.jsp&lt;/url-pattern&gt; 路径匹配和扩展名匹配是不能同时使用的。比如&lt;url-pattern&gt;/*.jsp&lt;/url-pattern&gt;就是一种错误的用法。 相同的&lt;url-pattern&gt;的问题在同一个web.xml内，是不允许使用一样的&lt;url-pattern&gt;，否则编译也不会通过。 但是Tomcat的web.xml和项目里的web.xml如果定义了相同的&lt;url-pattern&gt;是可以的，如果发生这种情况，那么会匹配项目里的&lt;url-pattern&gt;。 如果Tomcat的web.xml和项目的web.xml里都配置&lt;welcome-file-list&gt;了的话，那只有项目里的会生效，而不是把两个&lt;welcome-file-list&gt;合并起来。 结论先说这个项目的index.jsp是怎么实现欢迎页的因为Tomcat的web.xml里配置了12345&lt;welcome-file-list&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt;&lt;/welcome-file-list&gt; 当访问http://127.0.0.1:8080的时候，就会默认加上后缀，也就是会请求http://127.0.0.1:8080/index.html，如果404的话，就请求http://127.0.0.1:8080/index.htm，以此类推。 如果项目的web.xml里也配置&lt;welcome-file-list&gt;标签的话，Tomcat里的会被覆盖。 当请求http://127.0.0.1:8080/index.jsp的时候，因为匹配了定义在Tomcat的web.xml里的处理jsp的Servlet，所以显示成功了。 为什么把index.jsp换成index.html就不行了呢？因为http://127.0.0.1:8080/index.html匹配的是DispatcherServlet，而controller里找不到对应的handler，所以报错404了。 结语可能点比较多，描述的比较乱，其实弄清楚&lt;url-pattern&gt;的匹配优先级就基本能理解为什么index.html默认是不行的了。然后知道Tomcat的web.xml里有个处理jsp的jsp-servlet，和一个名叫default的可以处理静态资源的servlet就行了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[引用计数算法&根搜索算法]]></title>
      <url>%2FJVM%2FJVM%2F%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E7%AE%97%E6%B3%95%26%E6%A0%B9%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%2F</url>
      <content type="text"><![CDATA[要判断JVM中哪些对象是可以被回收的。有两种算法，一起了解一下。 引用计数算法实现方式给一个对象添加一个引用计数器，每当有一个地方引用它时，则引用计数器+1，当引用失效的时候-1。当减到0的时候，则说明该对象可以被回收了。 这个算法有个致命的缺陷，当有循环引用的时候就不行了。如下图，如果用引用计数算法，则这两个对象都不会被GC回收了。所以Java使用的是根搜索算法。 根搜索算法实现方法指定一系列的叫做“GC Roots”的对象，以这些对象作为起点往下遍历搜索，当有对象不在搜索的路径上的时候，也就是不可达的时候，则说明它该被回收了。 比如下图的Object2,3,4因为在搜索路径上，是可达的，所以不会被GC回收。而Object5,6,7虽然有互相引用，但是不在根搜索的路径上，是不可达的，所以会被GC视为可回收对象。 GC Roots那么哪些对象是GC Roots对象呢？ 虚拟机栈（栈帧中的本地变量表）中的引用的对象。 方法区的类静态属性引用的对象。 方法区的常量引用的对象。 本地方法栈中JNI（即Native方法）的引用的对象。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[反编译i++]]></title>
      <url>%2FJVM%2FJVM%2F%E5%8F%8D%E7%BC%96%E8%AF%91i%2B%2B%2F</url>
      <content type="text"><![CDATA[通过反编译来研究一下java的指令集 i = i++1234567public class Test &#123; public static void main(String... args) &#123; int i = 0; i = i++; System.out.println(i); //0 &#125;&#125; 使用javac编译后再使用javap -c Test反编译这个类查看它的字节码，如下（只摘取main方法）：1234567891011public static void main(java.lang.String[]);Code:0: iconst_01: istore_12: iload_13: iinc 1, 16: istore_17: getstatic #2; //Field java/lang/System.out:Ljava/io/PrintStream;10: iload_111: invokevirtual #3; //Method java/io/PrintStream.println:(I)V14: return 这里，我从第0行开始分析（分析中【】表示栈，栈的底端在左边，顶端在右边）： 0：将常数0压入栈，栈内容：【0】 1：将栈顶的元素弹出，也就是0，保存到局部变量区索引为为1（也就是变量i）的地方。栈内容：【】 2：将局部变量区索引为1（也就是变量i）的值压入栈，栈内容：【0】 3：将局部变量区索引为1（也就是常量i）的值加一，此时局部变量区索引为1的值（也就是i的值）是1。栈内容：【0】 6：将栈顶元素弹出，保存到局部变量区索引为1（也就是i）的地方，此时i又变成了0。栈内容：【】 7：获取常量池中索引为2所表示的类变量，也就是System.out。栈元素：【】 10：将局部变量区索引为1的值（也就是i）压入栈。栈元素：【0】 11：调用常量池索引为3的方法，也就是System.out.println 14：返回main方法 i = ++i1234567public class Test &#123; public static void main(String... args) &#123; int i = 0; i = ++i; System.out.println(i); //1 &#125;&#125; 同样javap -c Test1234567891011public static void main(java.lang.String...); Code: 0: iconst_0 //0入栈，【0】 1: istore_1 //栈顶出栈，并赋值给索引为1的变量，【】 2: iinc 1, 1 //索引为1的变量+1，【】 5: iload_1 //索引为1的变量入栈，【1】 6: istore_1 //栈顶出栈，并赋值给索引为1的变量，【】 7: getstatic #2 // Field java/lang/System.out:Ljava/io/PrintStream; 10: iload_1 11: invokevirtual #3 // Method java/io/PrintStream.println:(I)V 14: return i = i++ + ++i1234567public class Test &#123; public static void main(String... args) &#123; int i = 0; i = i++ + ++i; System.out.println(i); //2 &#125;&#125; 同样javap -c Test1234567891011121314public static void main(java.lang.String...); Code: 0: iconst_0 //0入栈，【0】 1: istore_1 //栈顶出栈，并赋值给索引为1的变量，【】 2: iload_1 //索引为1的变量入栈，【0】 3: iinc 1, 1 //索引为1的变量+1，【0】 6: iinc 1, 1 //索引为1的变量+1，【0】 9: iload_1 //索引为1的变量入栈，【0|2】 10: iadd //栈顶的两个整型相加并入栈，【2】 11: istore_1 //栈顶出栈，并赋值给索引为1的变量，【】 12: getstatic #2 // Field java/lang/System.out:Ljava/io/PrintStream; 15: iload_1 16: invokevirtual #3 // Method java/io/PrintStream.println:(I)V 19: return 通过图片理解指令int a = 100; int b = 98; int c = a+b;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java的内部类--成员内部类【1】]]></title>
      <url>%2FJava%E5%9F%BA%E7%A1%80%2Fjava%E5%9F%BA%E7%A1%80%2F%E5%86%85%E9%83%A8%E7%B1%BB%2Fjava%E7%9A%84%E5%86%85%E9%83%A8%E7%B1%BB--%E6%88%90%E5%91%98%E5%86%85%E9%83%A8%E7%B1%BB%E3%80%901%E3%80%91%2F</url>
      <content type="text"><![CDATA[例子一123456789101112131415161718192021222324252627282930313233public class InnerClassDemo01 &#123; public static void main(String[] args) &#123; OuterClass.InnerClass innerClass = new OuterClass().new InnerClass(); innerClass.print(); new Thread(innerClass).start(); &#125;&#125;class OuterClass &#123; private String name; public String getName() &#123; return name; &#125; public class InnerClass implements Runnable &#123; public InnerClass() &#123; name = "lxl"; //注意不要用this.name，this指的是内部类的。 &#125; public void run() &#123; System.out.println(name); &#125; public void print() &#123; System.out.println(getName()); &#125; &#125;&#125; 这个例子可以学到： 内部类可以随意的使用外部类的属性或方法。即使是private的。 如何获取成员内部类的实例，即：OuterClass.InnerClass innerClass = new OuterClass().new InnerClass()。 内部类也是可以继承或实现接口的。 例子二123456789101112131415161718public class InnerClassDemo02 &#123; public static void main(String[] args) &#123; new OuterClass02().new InnerClass02(); //编译报错 &#125;&#125;class OuterClass02 &#123; private class InnerClass02 &#123; static &#123; //编译报错 &#125; &#125; public OuterClass02 ()&#123; new InnerClass02(); &#125;&#125; 这个例子可以学到： 成员内部类和方法还有变量一样，也是被访问修饰符所限制住的。 我试着在外部类加了个get方法，返回一个内部类的实例。但是返回了实例发现也调用不了内部类的public方法。而且声明一个内部类也是报错的。 成员内部类里不能有static的属性，方法，静态块。 例子三12345678910111213141516171819202122public class InnerClassDemo03 &#123; public static void main(String[] args) &#123; OuterClass03 outer = new OuterClass03(); OuterClass03.InnerClass03 inner = outer.new InnerClass03(); System.out.println(outer == inner.getOuterClass()); //true System.out.println(outer == inner.getNewOuterClass()); //false &#125;&#125;class OuterClass03 &#123; public class InnerClass03 &#123; //获取外部类的引用 public OuterClass03 getOuterClass() &#123; return OuterClass03.this; &#125; public OuterClass03 getNewOuterClass() &#123; return new OuterClass03(); &#125; &#125;&#125; 这个例子可以学到： 如何获取当前外部类的引用，貌似没什么卵用。补充：在ArrayList的源码中看到，迭代器使用了内部类，并且通过1234567## 例子四我们已经知道如何获取一个内部类的实例```javapublic static void main(String[] args) &#123; new OuterClass().new InnerClass();&#125; 来看下反编译以后的代码12345public static void main(String[] args) &#123; OuterClass var10002 = new OuterClass(); var10002.getClass(); new InnerClass(var10002);&#125; 由于没有声明外部类的名字，所以反编译出来的名字是java生成的。 可以看到内部类其实是拿到了外部类的引用的。所以内部类可以轻松的访问到外部类的方法和属性。 例子五123456789101112131415161718192021222324252627public class InnerClassDemo04 &#123; public static void main(String[] args) &#123; new OuterClass04(); &#125;&#125;class OuterClass04 &#123; private String name; //定义个内部类 public class InnerClass04 &#123; private String name; private void print() &#123; System.out.println(name); &#125; &#125; public OuterClass04() &#123; InnerClass04 innerClass = new InnerClass04(); innerClass.name = "lxl"; innerClass.print(); //输出：lxl &#125;&#125; 这个例子可以学到： 外部类要调用内部类的方法就必须要拿到一个内部类的实例。而且外部类可以调用内部类的private方法。 在外部类里声明内部类可以省略外部类的类名，java会自动加上。 内部类的属性可以和外部类的属性重名，java会默认加上this . name，如果想用父类的那个，就可以用例子三了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java的内部类--局部内部类【2】]]></title>
      <url>%2FJava%E5%9F%BA%E7%A1%80%2Fjava%E5%9F%BA%E7%A1%80%2F%E5%86%85%E9%83%A8%E7%B1%BB%2Fjava%E7%9A%84%E5%86%85%E9%83%A8%E7%B1%BB--%E5%B1%80%E9%83%A8%E5%86%85%E9%83%A8%E7%B1%BB%E3%80%902%E3%80%91%2F</url>
      <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435363738public class InnerClassDemo05 &#123; public static void main(String[] args) &#123; new Outer05().printLocalClass(true); &#125;&#125;class Outer05 &#123; private String outerClassName = "Outer05"; public void printLocalClass(final boolean isPrintOuterClassName) &#123; //局部内部类前面不能有任何访问修饰符 class LocalClass implements Runnable &#123; private String localClassName = "localClass"; public void run() &#123; while (true) &#123; try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; /** * 局部内部类可以访问外部类域和局部变量，局部变量必须是final类型的 */ if (isPrintOuterClassName) &#123; System.out.println(outerClassName + " " + localClassName); &#125; else &#123; System.out.println(localClassName); &#125; &#125; &#125; &#125; new Thread(new LocalClass()).start(); &#125;&#125; 为什么方法一结束，程序还在不停的输出呢。我们用javap -private Outer05\$1LocalClass.class来反编译看看我们看到了创建了一个局部变量的副本。并且这个副本会被当作参数传入局部内部类的构造方法中。为什么要final类型的局部变量呢？（在java8里面可以省略不写final）因为外部方法随时会结束掉，而内部类如果引用了局部变量，那不就出错了嘛。所以内部类创建了一个副本，而假设局部变量如果改变了的话，内部类的变量没变（副本），那用户不是很迷惑，所以要统一就用final。（不过改变引用对象内部的值那也是没办法统一的。。比如改变数组里的某个值）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[重定向和转发的区别]]></title>
      <url>%2FTomcat%2FTomcat%2F%E9%87%8D%E5%AE%9A%E5%90%91%E5%92%8C%E8%BD%AC%E5%8F%91%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
      <content type="text"><![CDATA[说起重定向和转发，可能好多人的第一印象就是重定向的浏览器地址会变，而转发的不会变。下面说说为什么会这样。 重定向Tomcat7用的是servlet-api的3.0版本，文档如下 查看源码可以知道，重定向的时候，服务端会向客户端发送一个302的状态码（用这个可以劫持URL），还有一个重定向的地址，然后客户端会请求这个重定向的地址。所以造成了浏览器的地址变化。 而在重定向完的代码中，有个finally代码块，会清空request里的值。所以重定向是不能用上一次的request里的数据的。 转发1request.getRequestDispatcher(&quot;/xx/xxx/xxx.jsp&quot;).forward(request,response); 转发是直接在服务器完成的，所以转发以后是可以使用上一次的request里的数据的。当然在转发完成以后生成响应的时候也会清空request，但是已经使用好并返回客户端了，清空也无所谓了。 区别 重定向是在客户端完成的，转发是在服务端完成的。 重定向会丢失request里的parameter和attribute，转发不会。 重定向相当于客户端请求了两次，而转发只请求了一次。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java的内部类--静态内部类【4】]]></title>
      <url>%2FJava%E5%9F%BA%E7%A1%80%2Fjava%E5%9F%BA%E7%A1%80%2F%E5%86%85%E9%83%A8%E7%B1%BB%2Fjava%E7%9A%84%E5%86%85%E9%83%A8%E7%B1%BB--%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB%E3%80%904%E3%80%91%2F</url>
      <content type="text"><![CDATA[静态内部类和成员内部类差不多。1234567891011121314public class InnerClassDemo07 &#123; public static void main(String[] args) &#123; Outer07.Inner07 inner07 = new Outer07.Inner07(); &#125;&#125;class Outer07 &#123; static class Inner07 &#123; public Inner07() &#123; System.out.println("init"); &#125; &#125;&#125; 总结 静态内部类只能访问外部类的静态方法或变量 静态内部类的创建形式是：OuterClass.InnerClass inner = new OuterClass.InnerClass()]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java的内部类--匿名内部类【3】]]></title>
      <url>%2FJava%E5%9F%BA%E7%A1%80%2Fjava%E5%9F%BA%E7%A1%80%2F%E5%86%85%E9%83%A8%E7%B1%BB%2Fjava%E7%9A%84%E5%86%85%E9%83%A8%E7%B1%BB--%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E3%80%903%E3%80%91%2F</url>
      <content type="text"><![CDATA[匿名内部类也就是没有名字的内部类 正因为没有名字，所以匿名内部类只能使用一次，它通常用来简化代码编写 但使用匿名内部类还有个前提条件：必须继承一个父类或实现一个接口 实例1:不使用匿名内部类来实现抽象方法12345678910111213141516abstract class Person &#123; public abstract void eat();&#125; class Child extends Person &#123; public void eat() &#123; System.out.println("eat something"); &#125;&#125; public class Demo &#123; public static void main(String[] args) &#123; Person p = new Child(); p.eat(); &#125;&#125; 运行结果： eat something 可以看到，我们用Child继承了Person类，然后实现了Child的一个实例，将其向上转型为Person类的引用 但是，如果此处的Child类只使用一次，那么将其编写为独立的一个类岂不是很麻烦？ 这个时候就引入了匿名内部类 实例2：匿名内部类的基本实现1234567891011121314abstract class Person &#123; public abstract void eat();&#125; public class Demo &#123; public static void main(String[] args) &#123; Person p = new Person() &#123; public void eat() &#123; System.out.println("eat something"); &#125; &#125;; p.eat(); &#125;&#125; 运行结果： eat something 可以看到，我们直接将抽象类Person中的方法在大括号中实现了 这样便可以省略一个类的书写 并且，匿名内部类还能用于接口上 实例3：在接口上使用匿名内部类123456789101112131415interface Person &#123; public void eat();&#125; public class Demo &#123; public static void main(String[] args) &#123; Person p = new Person() &#123; public void eat() &#123; System.out.println("eat something"); &#125; &#125;; p.eat(); &#125;&#125; 由上面的例子可以看出，只要一个类是抽象的或是一个接口，那么其子类中的方法都可以使用匿名内部类来实现 最常用的情况就是在多线程的实现上，因为要实现多线程必须继承Thread类或是继承Runnable接口 实例4：在匿名内部类中自定义方法1234567891011121314public class InnerClassDemo06 &#123; public static void main(String[] args) &#123; new Thread()&#123; @Override public void run() &#123; get(); &#125; private void get()&#123; System.out.println(111); &#125; &#125;.get(); &#125;&#125; 运行结果： 111 可以看到可以定义自己的方法，并且就算是private的方法也可以访问到。但是别向上转型，即Thread t = new Thread(){};因为Thread里并没有get()方法。 总结 匿名内部类必须是基于一个抽象类或接口的。 匿名内部类是可以定义其他方法的。 匿名内部类是局部内部类的一种，所以局部内部类的所有限制都对其生效。 匿名内部类不能有static的变量，方法。 匿名内部类不能有构造方法，但是可以通过构造块{}来初始化。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[通过反射分析内部类【5】]]></title>
      <url>%2FJava%E5%9F%BA%E7%A1%80%2Fjava%E5%9F%BA%E7%A1%80%2F%E5%86%85%E9%83%A8%E7%B1%BB%2F%E9%80%9A%E8%BF%87%E5%8F%8D%E5%B0%84%E5%88%86%E6%9E%90%E5%86%85%E9%83%A8%E7%B1%BB%E3%80%905%E3%80%91%2F</url>
      <content type="text"><![CDATA[从成员内部类那篇教程里我们知道，内部类是可以拿到外部类的引用的，所以可以直接访问外部类的域，方法。 但是拿到了引用为什么能访问private类型的域或方法呢。我们用反射来打印下面这个外部类。123456789101112public class InnerClassDemo08 &#123; private String name; public class InnerClass &#123; public InnerClass() &#123; name = "lxl"; &#125; &#125;&#125; 得到结果 1234567public class cn.java.learning.innerclass.InnerClassDemo08&#123; private java.lang.String name; public cn.java.learning.innerclass.InnerClassDemo08(); static java.lang.String access$002(cn.java.learning.innerclass.InnerClassDemo08, java.lang.String);&#125; 可以看到有个隐藏的静态方法叫access$002，所以可以访问。每次调用外部类的域或方法，相当于是执行了方法access$002(外部类的引用) 反射的类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118public class ReflectionTest &#123; public static void main(String[] args) &#123; String className = "cn.java.learning.innerclass.InnerClassDemo08"; StringBuffer sb = new StringBuffer(); try &#123; Class cl = Class.forName(className); Class superCl = cl.getSuperclass(); sb. append(Modifier.toString(cl.getModifiers())). append(" class "). append(cl.getName()); if(superCl!=null&amp;superCl!= Object.class)&#123; sb.append(" extends ").append(superCl.getName()); &#125; sb.append("&#123;"); System.out.println(sb); ReflectionTest.printFields(cl); System.out.println(); ReflectionTest.printConstructors(cl); System.out.println(); ReflectionTest.printMethods(cl); System.out.println(); System.out.println("&#125;"); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; /** * 打印一个类的所有构造方法 * * @param cl 目标类 */ public static void printConstructors(Class cl) &#123; Constructor[] constructors = cl.getConstructors(); StringBuffer sb = new StringBuffer(); for (Constructor c : constructors) &#123; sb.append(" "); //缩进一个tab键的距离 String modifiers = Modifier.toString(c.getModifiers()); if (modifiers.length() &gt; 0) &#123; sb.append(modifiers).append(" "); //输出访问修饰符 &#125; sb.append(c.getName()).append("("); //输出类名 Class[] paramTypes = c.getParameterTypes(); for (int i = 0; i &lt; paramTypes.length; i++) &#123; if (i &gt; 0) &#123; sb.append(", "); &#125; sb.append(paramTypes[i].getName()); //输出形参的类型 &#125; sb.append(");"); System.out.println(sb); sb.delete(0, sb.length()); //清空 &#125; &#125; /** * 打印一个类的所有方法 * * @param cl 目标类 */ public static void printMethods(Class cl) &#123; Method[] methods = cl.getDeclaredMethods(); StringBuffer sb = new StringBuffer(); for (Method m : methods) &#123; sb. append(" "). append(Modifier.toString(m.getModifiers())). append(" "). append(m.getReturnType().getName()). append(" "). append(m.getName()). append("("); Class[] paramTypes = m.getParameterTypes(); for (int i = 0; i &lt; paramTypes.length; i++) &#123; if (i &gt; 0) &#123; sb.append(", "); &#125; sb.append(paramTypes[i].getName()); //输出形参的类型 &#125; sb.append(");"); System.out.println(sb); sb.delete(0, sb.length()); //清空 &#125; &#125; /** * 打印一个类中的所有域 * * @param cl 目标类 */ public static void printFields(Class cl) &#123; Field[] fields = cl.getDeclaredFields(); StringBuffer sb = new StringBuffer(); for (Field f : fields) &#123; sb. append(" "). append(Modifier.toString(f.getModifiers())). append(" "). append(f.getType().getName()). append(" "). append(f.getName()). append(";"); System.out.println(sb); sb.delete(0, sb.length()); //清空 &#125; &#125;&#125; 也可以通过javap命令来反编译.class文件直接得到结果javap -private className.calss]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java的内部类]]></title>
      <url>%2FJava%E5%9F%BA%E7%A1%80%2Fjava%E5%9F%BA%E7%A1%80%2F%E5%86%85%E9%83%A8%E7%B1%BB%2Fjava%E7%9A%84%E5%86%85%E9%83%A8%E7%B1%BB%2F</url>
      <content type="text"><![CDATA[内部类的分类如下，逐一分析。java的内部类–成员内部类【1】 java的内部类–局部内部类【2】 java的内部类–匿名内部类【3】 java的内部类–静态内部类【4】 通过反射分析内部类【5】]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Nginx+重定向导致的问题]]></title>
      <url>%2FTomcat%2FTomcat%2FNginx%2B%E9%87%8D%E5%AE%9A%E5%90%91%E5%AF%BC%E8%87%B4%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
      <content type="text"><![CDATA[场景描述在做项目迁移的时候，有个bug是页面跳转以后显示不出来： 1response.sendRedirect("/xxx/xxx.htm?action=xxx"); 原因是虽然Nginx设置了https的协议，但是根据下面的图片来看，response.sendRedirect()以后请求被重定向到http上了。 查了资料 解决方法： 找运维人员nginx配置： 1234proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; 在tomcat的server.xml里的Engine模块下加入： 1&lt;Valve className=&quot;org.apache.catalina.valves.RemoteIpValve&quot; protocolHeader=&quot;X-Forwarded-Proto&quot; /&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[git在push的时候显示the remote end hung up的解决办法 long的解决办法]]></title>
      <url>%2Fgit%2Fgit%2Fgit%E5%9C%A8push%E7%9A%84%E6%97%B6%E5%80%99%E6%98%BE%E7%A4%BAthe%20remote%20end%20hung%20up%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%2F</url>
      <content type="text"><![CDATA[今天在家华数网push的时候，一会提示 fatal: Could not read from remote repository 一会提示 The remote end hung up unexpectedly 就是push不成功。开始还以为是家里电脑没配好github的公钥。 但是可以pull成功的，排除这种可能。 后来尝试只修改一点点文件，发现可以push成功。 解决方法最后发现是华数网太坑了。。网速贼慢导致的push失败。。因为博客生成的静态文件太多，网速又慢，相当于git提交超时了。。略微设置一下就解决了这个问题了。 在git bash里运行这两句命令即可。123git config --global http.lowSpeedLimit 0git config --global http.lowSpeedTime 999999 单位都是秒。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[git clone的时候显示Filename too long的解决办法]]></title>
      <url>%2Fgit%2Fgit%2Fgit%20clone%E7%9A%84%E6%97%B6%E5%80%99%E6%98%BE%E7%A4%BAFilename%20too%20long%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%2F</url>
      <content type="text"><![CDATA[在Git bash中，运行下列命令即可：1git config --global core.longpaths true 如果只想对本次clone有效，只要在上述命令中去掉--global即可。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java设计模式--单例模式]]></title>
      <url>%2FJava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2FJava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2FJava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F--%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[单例模式介绍使用单例可以减少不必要的系统开销，比如Spring里配置的数据源，创建和销毁耗费大量的资源，所以就用单例来保证项目加载的时候只生成一个实例，大家公用该实例。Spring的bean默认都是Singleton的。 单例模式有以下特点： 单例类只能有一个实例。 单例类必须自己创建自己的唯一实例。 单例类必须给所有其他对象提供这一实例。 单例模式的写法我画了张图来总结一下我所知道的单例模式的写法。 具体代码演示 懒汉式12345678910111213141516public class SingletonDemo01 &#123; private static SingletonDemo01 instance = null; private SingletonDemo01() &#123; &#125; public static SingletonDemo01 getInstance() &#123; if (instance == null) &#123; instance = new SingletonDemo01(); &#125; return instance; &#125;&#125; 这个有线程安全问题：线程A判断完实例没有创建，刚刚准备创建对象的时候，时间片切换到第二个线程B，这个时候线程B也发现实例没有创建，然后两个线程就各创建了一个对象了。 饿汉式12345678910111213public class SingletonDemo02 &#123; private static SingletonDemo02 instance = new SingletonDemo02(); private SingletonDemo02() &#123; //设置私有构造外部就不能通过new来新建实例了。 &#125; public static SingletonDemo02 getInstance() &#123; return instance; &#125;&#125; 优点： 饿汉模式简单，也没有线程安全问题。 了解过类加载机制的同学可能要问，如果线程A和线程B同时触发了类加载机制怎么办呢？会不会在线程切换间创建两个对象？没关系，在jvm里，类加载的时候会自动的加锁，并且有CAS保证了只有一个对象被创建。具体细节这里不展开。 缺点： 如果我的类里定义了其他静态方法或静态变量，我只是想用一下静态方法或变量，依据getstatic指令触发类的初始化，这个时候，instance变量会跟着一起初始化，也就创建了一个SingletonDemo02的对象，白白浪费了内存。 单检锁12345678910111213141516public class SingletonDemo03 &#123; private static SingletonDemo03 instance = null; private SingletonDemo03() &#123; &#125; public synchronized static SingletonDemo03 getInstance() &#123; if (instance == null) &#123; instance = new SingletonDemo03(); &#125; return instance; &#125;&#125; 优点: 线程安全。 在懒汉式上加上了synchronized关键字，也就解决了普通懒汉式线程不安全的问题。 缺点： 锁的粒度太粗，instance==null的判断并不需要加锁。 双检锁1234567891011121314151617181920public class SingletonDemo04 &#123; private static volatile SingletonDemo04 instance = null; private SingletonDemo04() &#123; &#125; public synchronized static SingletonDemo04 getInstance() &#123; if (instance == null) &#123; synchronized (SingletonDemo04.class) &#123; if (instance == null) &#123; instance = new SingletonDemo04(); &#125; &#125; &#125; return instance; &#125;&#125; jvm创建对象的时候大致干三件事： 在堆上分配内存空间 执行类的构造方法初始化参数 把创建的对象指向分配的内存空间地址 在编译优化里，这几步的执行顺序并不是一定的，可能是123，也可能是132。 这里的volatile是为了防止132运行的时候，别的线程发现对象不为null，然后直接去操作对象里的某些参数。 优点: 线程安全，锁的粒度小 缺点： 多线程学的不扎实的可能很难理解。 静态内部类123456789101112131415public class SingletonDemo05 &#123; private SingletonDemo05() &#123; &#125; private static final class SingletonManager &#123; private static SingletonDemo05 instance = new SingletonDemo05(); &#125; public static SingletonDemo05 getInstance() &#123; return SingletonManager.instance; &#125;&#125; 优点: 改进了饿汉式的缺点，可以发现，现在即使SingletonDemo05里有其他的静态方法，只要我不调用getInstance()方法，我就不会白白的创建一个对象了。 枚举123456789101112131415161718public enum SingletonDemo06 &#123; INSTANCE; private Resource instance; SingletonDemo06() &#123; instance = new Resource(); &#125; public Resource getInstance() &#123; return instance; &#125;&#125;class Resource &#123;&#125; 优点： 前面的几种方式都可以通过反射和反序列化破坏掉 由于枚举类型的特性，保证了线程安全、反射安全和反序列化安全 在《Effective Java》书中有一句话是： 单元素的枚举类型已经成为实现Singleton的最佳方法。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[浅谈AOP]]></title>
      <url>%2FSpring%2FSpring%2F%E6%B5%85%E8%B0%88AOP%2F</url>
      <content type="text"><![CDATA[AOP（Aspect-Oriented Programming，面向切面编程）是一种编程的思想。是对OOP的补充和完善。OOP擅长纵向的编程，对横向编程无力，因为会产生大量重复代码。而AOP的横向编程能力正好弥补了这一缺陷。 java实现AOP1. 过滤器也就是Filter，技术基于java的回调机制。设计的模式使用的责任链模式。 2. 拦截器技术基于java的反射。设计的模式使用的代理模式。 可以是动态代理，也可以是静态代理。 因为使用了代理模式，所以可以在拦截前做一些事，在拦截后再做一些事。 过滤器和拦截器的区别 过滤器基于回调，拦截器基于反射。 过滤器依赖servler容器，拦截器不依赖servler容器。 过滤器几乎可以对任何请求起作用，拦截器只能对action请求起作用。 拦截器可以访问action上下文、值栈里的对象，过滤器不能。 在action生命周期中，拦截器可以多次被调用，而过滤器只能在容器初始化时被调用一次。 看了这几点可能有疑惑，看下书上是怎么写的吧 执行顺序一个action请求进来。 过滤前–&gt;拦截前–&gt;action处理–&gt;拦截后–&gt;过滤后 Spring实现AOP1. aop不要被Spring的aop给迷惑了，aop是种编程思想，而Spring的aop只是这种思想的具体实现。使用的也是代理模式。可以选择通过JDKProxy或cglib来代理。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ResponseEntity和@ResponseBody的区别]]></title>
      <url>%2FSpring%2FSpring%2FResponseEntity%E5%92%8C%40ResponseBody%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
      <content type="text"><![CDATA[问题我在controller里定义了两个简单的handler来返回一个消息。12345@RequestMapping(value = "/message")@ResponseBodypublic Message get() &#123; return new Message(penguinCounter.incrementAndGet() + " penguin!");&#125; 我也可以用下面这种形式12345@RequestMapping(value = "/message")ResponseEntity&lt;Message&gt; get() &#123; Message message = new Message(penguinCounter.incrementAndGet() + " penguin!"); return new ResponseEntity&lt;Message&gt;(message, HttpStatus.OK);&#125; 那么这两种实现方式有什么区别呢？ 答案ResponseEntity可以更加灵活的在response里添加header信息。 通过Spring官方文档里的第四个构造函数1ResponseEntity(T body, MultiValueMap&lt;String,String&gt; headers, HttpStatus statusCode) 比较常用的headers有Status,Content-Type和Cache-Control。 如果不需要自己设置，使用@ResponseBody会稍微简便一点。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[switch的用法]]></title>
      <url>%2FJava%E5%9F%BA%E7%A1%80%2Fjava%E5%9F%BA%E7%A1%80%2Fswitch%E7%9A%84%E7%94%A8%E6%B3%95%2F</url>
      <content type="text"><![CDATA[前言switch-case语句完全可以与if-else语句互转，但通常来说，switch-case语句执行效率要高。 default在当前switch找不到匹配的case时执行。default并不是必须的。 一旦case匹配，就会顺序执行后面的程序代码，而不管后面的case是否匹配，直到遇见break。（所以这里有坑要避免） switch支持的类型java7的switch支持一下几种类型 类型 char Character byte Byte int Integer short Short String(java7) enum(java5) 代码实例default的使用default在当前switch找不到匹配的case时执行。default并不是必须的。default并不一定要写在最后，但是好怪。。1234567891011121314public class Test004 &#123; public static void main(String[] args) &#123; int i = 4; switch (i)&#123; case 1: //这个值要和括号里变量的类型一样，不然编译报错 System.out.print(1); break; default: System.out.print(0); case 5: System.out.print(5); &#125; &#125;&#125; 输出结果: 05因为default后面没有break，所以会执行case5。如前言里所说。 switch使用枚举123456789101112131415161718public class Test005 &#123; static enum E &#123; A, B, C, D &#125; public static void main(String[] args) &#123; E e = E.B; //注意不要写成Enum e = E.b; 否则case那句会编译报错 switch (e) &#123; case A: System.out.println(1); break; default: System.out.println(0); &#125; &#125;&#125; 忘记写break的陷阱123456789101112131415public class Test007 &#123; public static void main(String[] args) &#123; int i = 2; switch (i)&#123; case 1: System.out.print(1); case 2: System.out.print(2); case 3: System.out.print(3); default: System.out.print(0); &#125; &#125;&#125; 输出结果: 230]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java数组复制的四种方式]]></title>
      <url>%2FJava%E5%9F%BA%E7%A1%80%2Fjava%E5%9F%BA%E7%A1%80%2Fjava%E6%95%B0%E7%BB%84%E5%A4%8D%E5%88%B6%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[我测试出来的效率如图。 但是clone方法和Arrays.copyOf谁快不好说，貌似和数据量也有关系。 反正System.arrayCopy肯定是最快的，因为是native的方法。ArrayList里用的也是这个方法。 Arrays.copyOf底层用的其实也是System.arrayCopy 测试代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public class ArrayCopyTest &#123; private static String[] src = &#123;"Aaaaaaaaaa", "Vvvvvvv", "Bbbb", "Cccc", "Dddd", "Eddeee", "FFFFFFffffffff", "Aaaaaaaaaa", "Vvvvvvv", "Bbbb", "Cccc", "Dddd", "Eddeee", "FFFFFFffffffff", "Aaaaaaaaaa", "Vvvvvvv", "Bbbb", "Cccc", "Dddd", "Eddeee", "FFFFFFffffffff", "Aaaaaaaaaa", "Vvvvvvv", "Bbbb", "Cccc", "Dddd", "Eddeee", "FFFFFFffffffff", "Aaaaaaaaaa", "Vvvvvvv", "Bbbb", "Cccc", "Dddd", "Eddeee", "FFFFFFffffffff", "Aaaaaaaaaa", "Vvvvvvv", "Bbbb", "Cccc", "Dddd", "Eddeee", "FFFFFFffffffff", "Aaaaaaaaaa", "Vvvvvvv", "Bbbb", "Cccc", "Dddd", "Eddeee", "FFFFFFffffffff", "Aaaaaaaaaa", "Vvvvvvv", "Bbbb", "Cccc", "Dddd", "Eddeee", "FFFFFFffffffff", "Aaaaaaaaaa", "Vvvvvvv", "Bbbb", "Cccc", "Dddd", "Eddeee", "FFFFFFffffffff", "Aaaaaaaaaa", "Vvvvvvv", "Bbbb", "Cccc", "Dddd", "Eddeee", "FFFFFFffffffff"&#125;; private static String[] dst; public static void main(String[] args) &#123; int num = 5000000; System.out.println(forCopy(num)); System.out.println(cloneCopy(num)); System.out.println(systemJNICopy(num)); System.out.println(ArraysToolCopy(num)); &#125; private static long forCopy(int num) &#123; long start = System.currentTimeMillis(); while (num-- &gt; 0) &#123; int size = src.length; dst = new String[size]; for (int i = 0; i &lt; size; i++) &#123; dst[i] = src[i]; &#125; &#125; long end = System.currentTimeMillis(); return end - start; &#125; private static long cloneCopy(int num) &#123; long start = System.currentTimeMillis(); while (num-- &gt; 0) &#123; dst = src.clone(); &#125; long end = System.currentTimeMillis(); return end - start; &#125; private static long systemJNICopy(int num) &#123; long start = System.currentTimeMillis(); while (num-- &gt; 0) &#123; System.arraycopy(src, 0, dst, 0, src.length); &#125; long end = System.currentTimeMillis(); return end - start; &#125; private static long ArraysToolCopy(int num) &#123; long start = System.currentTimeMillis(); while (num-- &gt; 0) &#123; dst = Arrays.copyOf(src, src.length); &#125; long end = System.currentTimeMillis(); return end - start; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[final的用法]]></title>
      <url>%2FJava%E5%9F%BA%E7%A1%80%2Fjava%E5%9F%BA%E7%A1%80%2Ffinal%E7%9A%84%E7%94%A8%E6%B3%95%2F</url>
      <content type="text"><![CDATA[用final可以修饰类，方法，变量。分别表示类不可被继承，方法不可重写，变量不可变（不可变指的是引用地址不可变，内部的值还是可以变的）。 代码实例final修饰的成员变量被final修饰的类变量就变成了常量，必须要进行初始化，有两次机会可以初始化，一是声明的时候直接初始化，或者在构造函数里初始化。12345678910111213141516public class Test008 &#123; final int PI; //编译报错，未初始化 public Test008()&#123; &#125; public Test008(int i)&#123; PI = i; &#125; public static void main(String[] args) &#123; &#125;&#125; 这段代码是有编译报错的，因为new Test008()的时候，PI是没有被初始化的。所以要嘛在无参构造里也加上初始化，要嘛删掉这个无参构造。 final修饰的局部变量123456public class Test008 &#123; public static void main(String[] args) &#123; final int i; System.out.println(i); //编译报错，未初始化 &#125;&#125; 局部变量和成员变量不一样在，可以声明成final且不初始化，但是在使用的地方会编译报错。 final定义的基本类型的运算Java表达式转型规则由低到高转换： 所有的byte,short,char型的值将被提升为int型； 如果有一个操作数是long型，计算结果是long型； 如果有一个操作数是float型，计算结果是float型； 如果有一个操作数是double型，计算结果是double型； 被final修饰的两个常量运算会直接在编译期间获得值； 例一123456public class Test &#123; public static void main(String... args) &#123; byte b1 = 1, b2 = 2, b3; b3 = (byte) (b1 + b2); //需要强转，因为计算结果为int &#125;&#125; 反编译结果123456789101112public static void main(java.lang.String[]); Code: 0: iconst_1 //整数1入栈，操作数栈【1】 1: istore_1 //弹出栈顶元素，赋值给索引为1的变量，操作数栈【】 2: iconst_2 //整数1入栈，操作数栈【2】 3: istore_2 //弹出栈顶元素，赋值给索引为2的变量，操作数栈【】 4: iload_1 //索引为1的变量的值入栈，操作数栈【1】 5: iload_2 //索引为2的变量的值入栈，操作数栈【1|2】 6: iadd //栈顶的两个元素相加，操作数栈【3】 7: i2b //把int型转成byte型，操作数栈【3】 8: istore_3 //弹出栈顶元素，赋值给索引为3的变量，操作数栈【】 9: return 例二123456public class Test &#123; public static void main(String... args) &#123; final byte b1 = 1, b2 = 2; byte b3 = b1 + b2; //不需要强转，因为这就是byte b3 = 3; &#125;&#125; 反编译结果123456789public static void main(java.lang.String[]); Code: 0: iconst_1 //将一个int型常量值推送至栈顶，操作数栈【1】 1: istore_1 //弹出栈顶元素，赋值给索引为1的变量，操作数栈【】 2: iconst_2 //将一个int型常量值推送至栈顶，操作数栈【2】 3: istore_2 //弹出栈顶元素，赋值给索引为2的变量，操作数栈【】 4: iconst_3 //将一个int型常量值推送至栈顶，操作数栈【3】 5: istore_3 //弹出栈顶元素，赋值给索引为3的变量，操作数栈【】 6: return 例三123456public class Test &#123; public static void main(String... args) &#123; final byte b1 = 127, b2 = 3; byte b3 = (byte) (b1 + b2); //需要强转，因为这就是byte b3 = 130;这是不合法的 &#125;&#125; 反编译结果123456789public static void main(java.lang.String[]); Code: 0: bipush 127 //将一个byte型常量值推送至栈顶，操作数栈【127】 2: istore_1 //弹出栈顶元素，赋值给索引为1的变量，操作数栈【】 3: iconst_3 //将一个int型常量值推送至栈顶，操作数栈【3】 4: istore_2 //弹出栈顶元素，赋值给索引为2的变量，操作数栈【】 5: bipush -126 //将一个byte型常量值推送至栈顶，操作数栈【-126】 7: istore_3 //弹出栈顶元素，赋值给索引为3的变量，操作数栈【】 8: return 这里为什么是bipush呢？因为-1 ~ 5使用iconst_m1 ~ iconst_5来入栈的。 例四1234567public class Test0 &#123; public static void main(String[] args) &#123; final byte b1 = 2; byte b2 = 3; byte b3 = (byte) (b1 + b2); //需要强转 &#125;&#125; 123456789101112public static void main(java.lang.String[]); Code: 0: iconst_2 //将一个int型常量值推送至栈顶，操作数栈【2】 1: istore_1 //弹出栈顶元素，赋值给索引为1的变量，操作数栈【】 2: iconst_3 //将一个int型常量值推送至栈顶，操作数栈【3】 3: istore_2 //弹出栈顶元素，赋值给索引为2的变量，操作数栈【】 4: iconst_2 //将一个int型常量值推送至栈顶，操作数栈【2】 5: iload_2 //索引为1的变量的值入栈，操作数栈【2|3】 6: iadd //栈顶的两个元素相加，操作数栈【5】 7: i2b //把int型转成byte型，操作数栈【5】 8: istore_3 //弹出栈顶元素，赋值给索引为3的变量，操作数栈【】 9: return 可以发现，例二和例三少了一个iadd的过程，final直接在编译阶段就计算出来了。 从例四可以看出，一个final类型和非final类型的数相加，final类的数是从常量池里取了以后压入栈的，而非final类的数是从变量里load了以后压入栈的。 例五12345678public class Test &#123; public static void main(String[] args) &#123; int i = 10; double d = 7.0; float f = (float) (i % d); System.out.println(f); &#125;&#125; 反编译后1234567891011121314151617 public static void main(java.lang.String[]); Code: 0: bipush 10 2: istore_1 3: ldc2_w #2 // double 7.0d //将long或double型常量值从常量池中推送至栈顶（宽索引） 6: dstore_2 7: iload_1 8: i2d //栈顶int值强转double值，并且结果进栈 9: dload_2 10: drem //栈顶两double型数值作取模运算，并且结果进栈 11: d2f //栈顶double值强转float值，并且结果进栈 12: fstore 4 //这里的4指的是第四个变量，fstore_1指的是第二个变量。 14: getstatic #4 // Field java/lang/System.out:Ljava/io/PrintStream; 17: fload 4 19: invokevirtual #5 // Method java/io/PrintStream.println:(F)V 22: return&#125; 可以看到，运算的时候，把int转成了double的，符合了小转大的规则；]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Math类中的几种取整方式]]></title>
      <url>%2FJava%E5%9F%BA%E7%A1%80%2Fjava%E5%9F%BA%E7%A1%80%2FMath%E7%B1%BB%E4%B8%AD%E7%9A%84%E5%87%A0%E7%A7%8D%E5%8F%96%E6%95%B4%E6%96%B9%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[方法名 作用 ceil 天花板，即向上取整，结果大于等于原值 floor 地板，即向下取整，结果小于等于原值 round 四舍五入，算法为Math.floor(x+0.5) 代码示例12345678910111213141516171819202122public class test001 &#123; public static void main(String[] args) &#123; System.out.println(Math.floor(-10.4)); //-11.0 System.out.println(Math.floor(-10.6)); //-11.0 System.out.println(Math.floor(10.4)); //10.0 System.out.println(Math.floor(10.6)); //10.0 System.out.println(Math.ceil(-10.4)); //-10.0 System.out.println(Math.ceil(-10.6)); //-10.0 System.out.println(Math.ceil(10.4)); //11.0 System.out.println(Math.ceil(10.6)); //11.0 System.out.println(Math.round(-10.1)); //-10 System.out.println(Math.round(-10.5)); //-10 System.out.println(Math.round(-10.9)); //-11 System.out.println(Math.round(10.1)); //10 System.out.println(Math.round(10.5)); //11 System.out.println(Math.round(10.9)); //11 &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[AngularJs验证动态生成的表单]]></title>
      <url>%2FJavaScript%2FJavaScript%2FAngularJs%E9%AA%8C%E8%AF%81%E5%8A%A8%E6%80%81%E7%94%9F%E6%88%90%E7%9A%84%E8%A1%A8%E5%8D%95%2F</url>
      <content type="text"><![CDATA[有这么一个需求，我的表单是ng-repeat生成的，但是要做表单验证。而AngularJs的表单验证是和name绑定的。如下。1234567&lt;p&gt;邮箱:&lt;br&gt; &lt;input type="email" name="email" ng-model="user.email" required&gt; &lt;span style="color:red" ng-show="myForm.email.$dirty &amp;&amp; myForm.email.$invalid"&gt; &lt;span ng-show="myForm.email.$error.required"&gt;邮箱是必须的。&lt;/span&gt; &lt;span ng-show="myForm.email.$error.email"&gt;非法的邮箱地址。&lt;/span&gt; &lt;/span&gt;&lt;/p&gt; 我把name改成{ {user.email} }，验证的地方改成myForm.{ {user.email} }.$error.required。报错。 解决方法google了一下，用ng-form标签123456789&lt;form name="outerForm"&gt;&lt;div ng-repeat="item in items"&gt; &lt;ng-form name="innerForm"&gt; &lt;input type="text" name="qwe" ng-model="item.foo" /&gt; &lt;span ng-show="innerForm.qwe.$error.required"&gt;required&lt;/span&gt; &lt;/ng-form&gt;&lt;/div&gt;&lt;input type="submit" ng-disabled="outerForm.$invalid" /&gt;&lt;/form&gt; 这里的name可以随便写了，只要和验证的地方对应就好了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java的八种基本类型的默认值]]></title>
      <url>%2FJava%E5%9F%BA%E7%A1%80%2Fjava%E5%9F%BA%E7%A1%80%2Fjava%E7%9A%84%E5%85%AB%E7%A7%8D%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E7%9A%84%E9%BB%98%E8%AE%A4%E5%80%BC%2F</url>
      <content type="text"><![CDATA[参见表格 基本类型 默认值 byte 0 short 0 int 0 long 0L float 0.0f double 0.0d char ‘\u0000’ boolean false 代码123456789101112131415161718192021222324252627/** * 实验基本类型的默认值 */public class Test002 &#123; private static byte defaultByte; //如果是final类型的话就必须初始化了，没有默认值 private static short defaultShort; private static int defaultInt; private static long defaultLong; private static float defaultFloat; private static double defaultDouble; private static char defaultChar; private static boolean defaultBoolean; private static String str; public static void main(String[] args) &#123; System.out.println(defaultByte); System.out.println(defaultShort); System.out.println(defaultInt); System.out.println(defaultLong); System.out.println(defaultFloat); System.out.println(defaultDouble); System.out.println(defaultChar); System.out.println(defaultBoolean); System.out.println("输出" + str); &#125;&#125; 输出00000.00.0 false输出null 注意点默认值只有成员变量才有，局部变量是没有默认值的。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java的八种基本类型~byte]]></title>
      <url>%2FJava%E5%9F%BA%E7%A1%80%2Fjava%E5%9F%BA%E7%A1%80%2Fjava%E7%9A%84%E5%85%AB%E7%A7%8D%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B~byte%2F</url>
      <content type="text"><![CDATA[byte可表示的位数 byte与int互转 byte的包装类 byte与字节流（TODO） byte可表示的位数 12&gt; -2^7&gt; 12&gt; \downarrow&gt; 12&gt; 2^7-1&gt; byte在java中是一字节的，而一字节在内存中是8bit，而8bit中，第一位又是符号位，那只有7位可以表示数字，所以 byte能表示的最大的正数在内存中是0111 1111，即 127 byte能表示的最小的负数在内存中是1000 0000，即-128 可以用byte的包装类Byte.java的静态常量来查看12345678public class Test01 &#123; public static void main(String[] args) &#123; System.out.println(Byte.MIN_VALUE + &quot;~&quot; + Byte.MAX_VALUE); //输出：-128~127 byte b = 128; //error，编译报错 byte c = 127; //编译通过 byte d = (byte)128; //编译通过 &#125;&#125; byte与int互转 byte转int好像也没什么需要注意的… 123456789101112131415161718public class Test01 &#123; public static void main(String[] args) &#123; /** * int在byte范围内 */ byte b = 10; System.out.println(b + 10); //输出： 20 int b1 = b; System.out.println(b1); //输出： 10 /** * int不在byte范围内 */ byte c = 127; System.out.println(c + 10); //输出： 137 int d = c + 10; System.out.println(d); //输出： 137，与上一句是一样的，java底层是int计算的。 &#125;&#125; int转byte123456789101112131415161718public class Test01 &#123; public static void main(String[] args) &#123; int i = 128; byte j = (byte) i; //不强转编译报错 System.out.println(j); //输出： -128 int m = -129; byte n = (byte) m; //不强转编译报错 System.out.println(n); //输出： 127 int a = 127; byte b = (byte) a; //不强转编译报错 System.out.println(b); //输出： 127 byte e = 127; //这里字面量是int，为什么不用强转呢，jvm做了处理 System.out.println(e); //输出： 127 byte c = 127; byte d = 1; byte e = c + d; //error，编译报错，必须加上强转。因为java计算是通过int的。 &#125;&#125; [TODO:计算一下为什么128变成了-128] byte的包装类byte的包装类就是Byte，列举一下常见方法 12345678910111213- toString(byte b) //静态的，调用了Integer.toString()- ByteCache() //不是很懂，也不是静态方法啊- parseByte(String s) //超过范围或者不是数字会报：NumberFormatException，调用了Integer.parseInt()- valueOf() //把括号里的参数变成Byte对象，超过范围或者不是数字会报：NumberFormatException- byteValue() //返回Byte里的byte- shortValue() //返回short，代码里加了强转，平时不写是隐式类型转换，jvm实现的。- intValue(),longValue() //同上- floatValue(),doubleValue() //同上，但是不知道精度是否会丢失【TODO】- toString() //源码里调用了Integer.toString，非静态- hashCode() //返回这个类的hashCode- equals() //直接比byte了，也不用比hashCode了- compareTo(Byte anotherByte) //和另外一个Byte比较大小- compare(byte x, byte y) //静态方法 ByteCache可以查看128的hashCode共享 12345678910111213141516public class Test01 &#123; public static void main(String[] args) &#123; System.out.println(Byte.toString((byte) 1)); //1 System.out.println(Byte.parseByte(&quot;129&quot;)); //NumberFormatException：Value out of range. Value:&quot;129&quot; Radix:10 System.out.println(Byte.parseByte(&quot;x&quot;)); //NumberFormatException：For input string: &quot;x&quot; System.out.println(Byte.parseByte(&quot;20&quot;)); //20，调用了重写的toString方法 System.out.println(Byte.valueOf(&quot;20&quot;)); //20，与parseByte()的区别是返回类型不同，这个返回Byte System.out.println(Byte.valueOf((byte) 130)); //-126，与parseByte()的区别是返回类型不同，这个返回Byte Byte testByte = new Byte(&quot;-5&quot;); System.out.println(testByte.shortValue()); //-5 System.out.println(testByte.intValue()); //-5 System.out.println(testByte.longValue()); //-5 System.out.println(testByte.floatValue()); //-5.0 System.out.println(testByte.doubleValue()); //-5.0 &#125;&#125; Byte是final类型的类，也就是不可变的。（其他的基本类型的包装类也都是final类型的）下面的例子可以验证。1234567891011121314151617/** * 试验包装类的自增。 */public class Test001 &#123; private static void add(Byte b) &#123; b = b++; &#125; public static void main(String[] args) &#123; Byte a = 127; Byte b = 127; add(++a); System.out.println(a); //-128，自动拆箱 add(b); System.out.println(b); //127 &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[通过js实现导入导出txt格式]]></title>
      <url>%2FJavaScript%2FJavaScript%2F%E9%80%9A%E8%BF%87js%E5%AE%9E%E7%8E%B0%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BAtxt%E6%A0%BC%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[项目中有一个需求是要导出页面上的配置，然后又不想走后台来实现。google之~ 导出使用FileSaver.min.js FileSaver.min.js的github地址 示例（项目用的是AngularJs）:12345678910PatientVisitModel.prototype.downloadConfig = function () &#123; var saveText = &#123;&#125;; saveText.currentType = this.currentType; saveText.currentConfig = this.uiConfigs; var blob = new Blob([JSON.stringify(saveText)], &#123;type: "text/plain;charset=utf-8"&#125;); saveAs(blob, "hello world.txt");&#125;; 导入使用HTML5.JS的FileReader对象123456789101112131415PatientVisitModel.prototype.uploadConfig = function (myFile) &#123; var self = this; var file = myFile.files[0]; var reader = new FileReader(); //将文件以文本形式读入页面 reader.readAsText(file); reader.onload = function() &#123; var resultText = JSON.parse(this.result); self.uiConfigs = resultText.currentConfig; self.currentType = resultText.currentType; &#125;;&#125;; html页面上的写法1&lt;input type="file" id="file-input" onchange="angular.element(this).scope().patientVisitModel.uploadConfig(this)" &gt;]]></content>
    </entry>

    
  
  
</search>
